<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郑保乐的博客</title>
  
  <subtitle>James&#39; Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://james.letec.top/"/>
  <updated>2018-06-04T14:50:31.907Z</updated>
  <id>https://james.letec.top/</id>
  
  <author>
    <name>郑保乐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式学习笔记（17）策略</title>
    <link href="https://james.letec.top/2018/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8817%EF%BC%89%E7%AD%96%E7%95%A5/"/>
    <id>https://james.letec.top/2018/05/20/设计模式学习笔记（17）策略/</id>
    <published>2018-05-20T13:56:00.000Z</published>
    <updated>2018-06-04T14:50:31.907Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>在策略（Strategy Pattern）模式中，一个类的行为或某个接口的实现方法可以在运行时进行更换，通常这种类型的设计模式属于行为型模式。</p><p>在策略模式中，我们通常的做法是创建一个对象来封装各种策略，创建一个上下文对象，策略对象作为上下文对象的子对象被调用，通过策略对象的改变就可以实现上下文对象在不同策略下的具体功能。现实生活中就有策略模式的例子，比如用不同的方式出行，乘坐不同的交通工具就是应用了不同的策略。<br><a id="more"></a></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>居住在北京的一个人即将参加一个重要的会议，他现在面临着出行方式的选择，他的参考依据有目的地、价格、时间等。我们可以将出行方式抽象为一种策略，用接口来表示：</p><p>TransportationStrategy.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransportationStrategy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中唯一的方法就是 <code>go()</code>，出行。</p><p>根据不同的目的地，我们可能会乘坐不同的交通工具，比如，从北京到广州我们会选择飞机，从北京到上海我们会选择高铁，而从北京到天津，可能驾驶私家车就够了。策略是随着需求的变化而更换的，这极大的方便了同一种算法集合在不同的场景下的切换。</p><p>所以，我们定义 <code>TransportationStrategy</code> 接口的三种不同实现，分别用来表示乘坐三种交通工具：</p><p>TransportationAirplane.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransportationAirplane</span> <span class="keyword">implements</span> <span class="title">TransportationStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TransportationAirplane.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"乘飞机从北京去广州"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>TransportationTrain.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransportationTrain</span> <span class="keyword">implements</span> <span class="title">TransportationStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TransportationTrain.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"乘高铁从北京去上海"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>TransportationVehicle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransportationVehicle</span> <span class="keyword">implements</span> <span class="title">TransportationStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TransportationVehicle.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"驾车从北京去天津"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，商人的实例一经创建，就可以调用它的 <code>changetStrategy()</code> 方法来更换策略了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BusinessMan man = <span class="keyword">new</span> BusinessMan(<span class="keyword">new</span> TransportationAirplane());</span><br><span class="line">    man.transport();</span><br><span class="line"></span><br><span class="line">    man.changetStrategy(<span class="keyword">new</span> TransportationTrain());</span><br><span class="line">    man.transport();</span><br><span class="line"></span><br><span class="line">    man.changetStrategy(<span class="keyword">new</span> TransportationVehicle());</span><br><span class="line">    man.transport();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>商人分别出席了三个地方的三个会议，通过不同的交通工具，最终都平安到达了目的地。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面例子中的 <code>BusinessMan</code> 就是上下文对象，它负责维护一个策略类的实例， <code>BusinessMan</code> 通过持有不同的策略实现类来获得不同的功能。</p><p>策略模式的几个优势：</p><ul><li>策略模式符合开闭原则，每当增加一种新的需求场景，只需要新增一个策略实现类即可，客户无需修改原有的类。</li><li>使用策略模式可以减少许多 <code>if else</code> 语句，因为策略的不同实现本身就代表了不同的情形</li></ul><p>策略模式的不足：</p><ul><li>客户可以使用某个策略的前提是要实现知道有这个策略，选择哪个策略是由客户决定的</li><li>不支持为不同的客户适配不同的策略</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在策略（Strategy Pattern）模式中，一个类的行为或某个接口的实现方法可以在运行时进行更换，通常这种类型的设计模式属于行为型模式。&lt;/p&gt;
&lt;p&gt;在策略模式中，我们通常的做法是创建一个对象来封装各种策略，创建一个上下文对象，策略对象作为上下文对象的子对象被调用，通过策略对象的改变就可以实现上下文对象在不同策略下的具体功能。现实生活中就有策略模式的例子，比如用不同的方式出行，乘坐不同的交通工具就是应用了不同的策略。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记（16）状态</title>
    <link href="https://james.letec.top/2018/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8816%EF%BC%89%E7%8A%B6%E6%80%81/"/>
    <id>https://james.letec.top/2018/05/20/设计模式学习笔记（16）状态/</id>
    <published>2018-05-20T13:56:00.000Z</published>
    <updated>2018-05-21T11:50:45.281Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>状态模式（State）最明显的特点是可以使类的行为根据不同的状态变化而变化，很明显，这是一种行为型模式。通常用一个上下文对象将某个类的对象进行一层包裹，将该类在不同状态下的具体行为分别交给不同状态的上下文类来实现。该模式的完美的将类的行为和它的状态进行了解耦，如果某个类增添一种状态，只需要增加新的状态类就可以了。<br><a id="more"></a></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>我们在开发过程中难免会遇到一些 bug，有些非常棘手的 bug 会让我们非常焦虑，一旦解决了这些问题，我们就如释重负的放松下来了。我们在心情平静时和被 bug 困扰时就是分别处于两种不同的状态，而我们在这两种状态下的行为表现也有所不同。</p><p>定义一个 <code>State</code> 接口，它包含了所有状态类的行为：</p><p>State.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入状态之前</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onPreparing</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 进入状态之后</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onEnterState</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 <code>Code</code> 类， 它有两种行为表现 —— 进入状态前的表现和进入状态后的表现：</p><p>Coder.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Coder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">new</span> IdleState(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 切换状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeStateTo</span><span class="params">(State newState)</span> </span>&#123;</span><br><span class="line">    state.onEnterState();</span><br><span class="line">    <span class="keyword">this</span>.state = newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 模拟过了一段时间</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timePass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state.getClass().equals(ImpatientState.class)) &#123;</span><br><span class="line">      changeStateTo(<span class="keyword">new</span> IdleState(<span class="keyword">this</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      changeStateTo(<span class="keyword">new</span> ImpatientState(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 准备进入状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    state.onPreparing();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两种不同的状态类，它们都实现 <code>State</code> 接口：</p><p>IdleState.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 平静的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdleState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(IdleState.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Coder coder;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">IdleState</span><span class="params">(Coder coder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.coder = coder;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreparing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125;正努力使自己变得平静"</span>, coder);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEnterState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125;正悠闲的听着歌"</span>, coder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImpatientState.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 焦虑的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImpatientState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ImpatientState.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Coder coder;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ImpatientState</span><span class="params">(Coder coder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.coder = coder;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreparing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125;面对一堆 bug，开始逐渐焦躁起来"</span>, coder);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEnterState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125;已经被 bug 搞的进入了极度狂躁的状态"</span>, coder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来模拟一下程序员的这两种状态：</p><p>App.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Coder coder = <span class="keyword">new</span> Coder();</span><br><span class="line">    coder.prepare();</span><br><span class="line">    coder.timePass();</span><br><span class="line">    coder.prepare();</span><br><span class="line">    coder.timePass();</span><br><span class="line">    coder.prepare();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>状态模式解决了当一个类有多种不同状态时设计过于复杂的问题，它将类在不同状态下的行为和该类本身进行了解耦，将这些行为独立到另一个接口中，该类的状态发生改变后只需要添加新的类即可。</p><p>之前文章中的命令模式的接口中只有一个方法，但状态模式的接口中有可以有更多方法，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。</p><p>状态模式封装了转换规则，所以用枚举的形式判断目前的状态，根据不同的状态确定使用的具体状态实现类。将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。允许状态转换逻辑与状态对象合成一体，这就避免了一个很大的条件判断代码块。</p><p>状态模式的使用会增加系统中类和对象的个数，所以状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。状态模式虽然可以方便的添加新的状态实现类，但它也并不是完全支持”开闭原则”的，因为当状态需要切换的时候，增加新的状态类同样还要要修改和状态转换相关的代码，而且修改某个状态实现类的行为都要修改那个类。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;状态模式（State）最明显的特点是可以使类的行为根据不同的状态变化而变化，很明显，这是一种行为型模式。通常用一个上下文对象将某个类的对象进行一层包裹，将该类在不同状态下的具体行为分别交给不同状态的上下文类来实现。该模式的完美的将类的行为和它的状态进行了解耦，如果某个类增添一种状态，只需要增加新的状态类就可以了。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记（15）观察者</title>
    <link href="https://james.letec.top/2018/05/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8815%EF%BC%89%E8%A7%82%E5%AF%9F%E8%80%85/"/>
    <id>https://james.letec.top/2018/05/17/设计模式学习笔记（15）观察者/</id>
    <published>2018-05-17T08:03:00.000Z</published>
    <updated>2018-05-17T13:01:53.677Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>观察者（Observer）模式实现了一种一对多的通信方式，它的核心是由多个对象监听中心对象，中心对象发生某种变化时将这个变化通知给关注它的周边对象，所以，它又被称为 “订阅-发送” 模式。</p><p>在现实生活中也有许多和观察者模式的运作方式相似的例子，比如当我们订阅某个公众号后，一旦该公众号的主人发不了新的文章或消息，所有订阅这个公众号的用户都会受到这个消息。这些用户就对应着观察者模式里的订阅者，公众号对应着发布者，一旦订阅者对关注点失去了兴趣，就会取消对发布者的订阅，也就不会再受到发布者的任何消息了。所以，实现观察者模式的主要方法就是订阅和发布。</p><a id="more"></a><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>我们的祖国地大物博，南方人和北方人的生活习惯在某些方面的差异是很大的，这一点饮食习惯上可以非常容易看出来。所以我们现在用一天中不同时段，南方人和北方人的饮食活动举个例子。</p><p>现在有一个智能闹钟，南方人和北方人都在这个闹钟上定时，每到特定时刻，这个闹钟就会分别提醒它的用户。所以，用户要统一实现一个接口，以便闹钟能够调用用户中的方法来通知用户，这个接口同时代表了订阅者的关注点，即时间的变化。首先定义一个枚举类来表示不同的时间点：</p><p>TimePoint.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TimePoint &#123;</span><br><span class="line">  MORNING(<span class="string">"早晨"</span>), NOON(<span class="string">"中午"</span>), AFTERNOON(<span class="string">"下午"</span>), EVENING(<span class="string">"晚上"</span>);</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  TimePoint(String name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有闹钟的用户都要实现的接口 <code>TimeObserver</code>，通过接口实现了发布者向订阅者传递消息：</p><p>TimeObserver.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimeObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(TimePoint time)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>南方的朋友和北方的朋友分别实现 <code>TimeObserver</code> 接口：</p><p>Southern.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Southern</span> <span class="keyword">implements</span> <span class="title">TimeObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Southern.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(TimePoint time)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">"南方的朋友吃饭了"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (time) &#123;</span><br><span class="line">      <span class="keyword">case</span> MORNING:</span><br><span class="line">        LOGGER.info(<span class="string">"热干面"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NOON:</span><br><span class="line">        LOGGER.info(<span class="string">"米饭"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AFTERNOON:</span><br><span class="line">        LOGGER.info(<span class="string">"茶"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> EVENING:</span><br><span class="line">        LOGGER.info(<span class="string">"鱼"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Northern.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Northern</span> <span class="keyword">implements</span> <span class="title">TimeObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Northern.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(TimePoint time)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">"北方人吃饭了"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (time) &#123;</span><br><span class="line">      <span class="keyword">case</span> MORNING:</span><br><span class="line">        LOGGER.info(<span class="string">"煎饼果子"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NOON:</span><br><span class="line">        LOGGER.info(<span class="string">"炸酱面"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AFTERNOON:</span><br><span class="line">        LOGGER.info(<span class="string">"牛奶"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> EVENING:</span><br><span class="line">        LOGGER.info(<span class="string">"包子"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面开始定义时间点消息的发布者 <code>Time</code>，也就是上文中的闹钟：</p><p>Time.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Time</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Time.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> TimePoint point;</span><br><span class="line">  <span class="keyword">private</span> List&lt;TimeObserver&gt; observers;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Time</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.point = TimePoint.MORNING;</span><br><span class="line">    observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(TimeObserver observer)</span> </span>&#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(TimeObserver observer)</span> </span>&#123;</span><br><span class="line">    observers.remove(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TimePoint[] points = TimePoint.values();</span><br><span class="line">    point = points[(point.ordinal() + <span class="number">1</span>) % points.length];</span><br><span class="line">    LOGGER.info(<span class="string">"时间来到了&#123;&#125;"</span>, point);</span><br><span class="line">    notifyObservers();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TimeObserver observer : observers) &#123;</span><br><span class="line">      observer.update(point);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Time</code> 对象持有一系列 <code>TimeObserver</code> 对象的引用，每当时间点发生变化， <code>Time</code> 就会通过调用 <code>TimeObserver</code> 的 <code>update()</code> 方法，下面模拟一下这个闹钟的使用过程：</p><p>App.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Time time = <span class="keyword">new</span> Time();</span><br><span class="line">    time.addObserver(<span class="keyword">new</span> Northern());</span><br><span class="line">    time.addObserver(<span class="keyword">new</span> Southern());</span><br><span class="line"></span><br><span class="line">    time.passing();</span><br><span class="line">    time.passing();</span><br><span class="line">    time.passing();</span><br><span class="line">    time.passing();</span><br><span class="line">    time.passing();</span><br><span class="line">    time.passing();</span><br><span class="line">    time.passing();</span><br><span class="line">    time.passing();</span><br><span class="line">    time.passing();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是整个包的类图</p><p><img src="https://upload-images.jianshu.io/upload_images/7134080-ef24103f141c9740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>观察者模式的具体应用形式可能多种多样，但都包括以下几点共性：</p><ul><li>发布者（被观察方）和订阅者（观察方）通常是一对多的关系，即发布者可以同时被多个订阅者订阅，所以比较常用的方式是用发布者用集合的方式维护一系列订阅者</li><li>可以通过控制发布者的实现细节来控制最终是否向某个订阅者发布消息</li><li>订阅者的关注点发生变化时，发布者通过接口回调来通知订阅者</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;观察者（Observer）模式实现了一种一对多的通信方式，它的核心是由多个对象监听中心对象，中心对象发生某种变化时将这个变化通知给关注它的周边对象，所以，它又被称为 “订阅-发送” 模式。&lt;/p&gt;
&lt;p&gt;在现实生活中也有许多和观察者模式的运作方式相似的例子，比如当我们订阅某个公众号后，一旦该公众号的主人发不了新的文章或消息，所有订阅这个公众号的用户都会受到这个消息。这些用户就对应着观察者模式里的订阅者，公众号对应着发布者，一旦订阅者对关注点失去了兴趣，就会取消对发布者的订阅，也就不会再受到发布者的任何消息了。所以，实现观察者模式的主要方法就是订阅和发布。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记（14）备忘录</title>
    <link href="https://james.letec.top/2018/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8814%EF%BC%89%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>https://james.letec.top/2018/05/14/设计模式学习笔记（14）备忘录/</id>
    <published>2018-05-14T06:18:00.000Z</published>
    <updated>2018-05-14T11:43:49.082Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>备忘录模式（Memento），别名为快照模式（Snapshot），是的行为型模式的一种。它的主要特点是创建一个特殊对象用于保存其他若干个对象在某一刻的状态，以便在需要获得该状态的时候能够及时恢复。</p><a id="more"></a><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>一粒种子从被播种到发芽再到开花会经历很长的时间，虽然我们用肉眼看不出来它在长大，但它的确每时每刻都在生长。植物生长过程中的每一刻的状态都是不完全相同的，所以我们可以用一个“快照”来保存植物的若干个状态。</p><p>我们暂时不考虑植物学上各种微观的状态，所以简单定义一下植物，它的状态由高度和重量组成，同时，植物区分不同的生长阶段：</p><p>Plant.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">FlowerType <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个花朵类 <code>Flower</code>，它实现植物 <code>Plant</code> 接口，以获得其生长过程中某一时刻的状态，同时花朵可以生长，为了模拟生长过程，我们自定义一个生长速度计算公式，并且每次调用 <code>growing</code> 方法都会使花朵的阶段向下移阶段跳转，比如花朵处于种子阶段的时候，生长一次就处于了 “花苞” 的阶段。</p><p>模拟花朵生长的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">growing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  setWeight(getWeight() * <span class="number">2</span>);</span><br><span class="line">  setHeight(getHeight() * <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SEED: &#123;</span><br><span class="line">      setType(FlowerType.BURGEON);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BURGEON: &#123;</span><br><span class="line">      setType(FlowerType.BUD);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BUD: &#123;</span><br><span class="line">      setType(FlowerType.BLOOM);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BLOOM: &#123;</span><br><span class="line">      setType(FlowerType.DEAD);</span><br><span class="line">      setHeight(<span class="number">0</span>);</span><br><span class="line">      setWeight(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在花朵类中定义一个私有的静态内部类 <code>FlowerMemento</code>，这个类负责记录花朵的生长状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowerMemento</span> <span class="keyword">implements</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> FlowerType type;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">FlowerMemento</span><span class="params">(FlowerType type, <span class="keyword">int</span> height, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> FlowerType <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个枚举类来定义花朵的生长阶段：</p><p>FlowerType.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FlowerType &#123;</span><br><span class="line"></span><br><span class="line">  SEED(<span class="string">"种子"</span>), BURGEON(<span class="string">"发芽"</span>), BUD(<span class="string">"花苞"</span>), BLOOM(<span class="string">"开放"</span>), DEAD(<span class="string">"凋零"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  FlowerType(String name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于理清这几个类之间的关系，现在给出完整的 <code>Flower</code> 类：</p><p>Flower.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flower</span> <span class="keyword">implements</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> FlowerType type;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">growing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上文给出了完整的此方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">FlowerMemento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FlowerMemento(getType(), getHeight(), getWeight());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Plant plant)</span> </span>&#123;</span><br><span class="line">    FlowerMemento flowerMemento = (FlowerMemento) plant;</span><br><span class="line">    setType(flowerMemento.getType());</span><br><span class="line">    setHeight(flowerMemento.getHeight());</span><br><span class="line">    setWeight(flowerMemento.getWeight());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">"名称：%s\t状态：%s\t质量：%d克\t高度：%d厘米"</span>, getName(), getType(), getWeight(), getHeight());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Flower</span><span class="params">(FlowerType type, String name, <span class="keyword">int</span> height, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter &amp; setter ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowerMemento</span> <span class="keyword">implements</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FlowerType type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FlowerMemento</span><span class="params">(FlowerType type, <span class="keyword">int</span> height, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.type = type;</span><br><span class="line">      <span class="keyword">this</span>.height = height;</span><br><span class="line">      <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter &amp; setter ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后模拟一下花朵的生长过程：</p><p>App.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Application.class);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Flower flower = <span class="keyword">new</span> Flower(FlowerType.SEED, <span class="string">"水仙花"</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    LOGGER.info(flower.toString());</span><br><span class="line">    flower.growing();</span><br><span class="line">    LOGGER.info(flower.toString());</span><br><span class="line">    flower.growing();</span><br><span class="line">    LOGGER.info(flower.toString());</span><br><span class="line">    flower.growing();</span><br><span class="line">    LOGGER.info(flower.toString());</span><br><span class="line">    flower.growing();</span><br><span class="line">    LOGGER.info(flower.toString());</span><br><span class="line">    flower.growing();</span><br><span class="line">    LOGGER.info(flower.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这个例子可以总结出，备忘录模式的主要特点有：</p><p>在不修改被捕获对象的原有状态前提下，抓取一个对象的内部状态，并在独立于该对象的对象中保存被捕获对象的状态。所以应该使用静态内部类作为快照保存的实现，因为对象的状态和对象没有直接紧密的联系，而是相对的独立联系。</p><p>为了保证状态持有者的数据不允许被除了 “被捕获对象” 之外的对象访问到，应当将状态持有者的类定义为 “被捕获对象类” 的私有类。</p><p>在许多的软件中，都需要保存当前工作进度的功能，所以这些正是备忘录模式的使用场景：</p><ul><li>游戏软件中的存档</li><li>字处理软件（比如 MS Office）中 “撤销上一步” 的操作</li><li>浏览器中的返回上一页</li><li>数据库中的事务回滚</li></ul><p>为了避免每次保存状态和恢复状态耗费较多内存资源，可以将备忘录模式和之前的文章中提到的原型模式结合使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;备忘录模式（Memento），别名为快照模式（Snapshot），是的行为型模式的一种。它的主要特点是创建一个特殊对象用于保存其他若干个对象在某一刻的状态，以便在需要获得该状态的时候能够及时恢复。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记（13）中介者</title>
    <link href="https://james.letec.top/2018/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8813%EF%BC%89%E4%B8%AD%E4%BB%8B%E8%80%85/"/>
    <id>https://james.letec.top/2018/05/13/设计模式学习笔记（13）中介者/</id>
    <published>2018-05-13T06:20:00.000Z</published>
    <updated>2018-05-13T08:14:37.905Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>中介者（Mediator）模式是用来降低多个对象和类之间的通信复杂性的。这种模式中通常提供一个充当中介者角色的类，用来承担“中心化”或“集中化”的职能，与各个对象之间都可以分别相互通信，它的一大优势是减少或避免其他对象之间的互相通信，在通信方面降低了耦合度。<br><a id="more"></a></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>现在要举行一场派对，派对中会穿插各种游戏活动，凡是参加派对的人都要到派对举办者那里登记。并且，每次有参与者想要参加派对中的某个活动的时候都要先向派对举办者提出请求，由举办者来批准他的请求，然后这个活动才开始进行。</p><p>先定义派对举办者行为的接口，举办者的职责有邀请成员加入和批准成员参加活动</p><p>Party.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Party</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addMember</span><span class="params">(PartyMember member)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">letAct</span><span class="params">(PartyMember member, Activity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是派对成员的接口，成员的职责有参加派对、提出参加活动的请求以及参加活动</p><p>PartyMember.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PartyMember</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">joinParty</span><span class="params">(Party party)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">partyActivity</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">act</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个类来具体实现派对举办者功能</p><p>PartyImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartyImpl</span> <span class="keyword">implements</span> <span class="title">Party</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;PartyMember&gt; members;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PartyImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    members = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMember</span><span class="params">(PartyMember member)</span> </span>&#123;</span><br><span class="line">    members.add(member);</span><br><span class="line">    member.joinParty(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">letAct</span><span class="params">(PartyMember member, Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (PartyMember m : members) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!member.equals(m)) &#123;</span><br><span class="line">        m.partyActivity(activity);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个派对实现成员接口的抽象类，保留一个 <code>toString()</code> 抽象方法，留到其具体子类中实现</p><p>AbstractPartyMember.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPartyMember</span> <span class="keyword">implements</span> <span class="title">PartyMember</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(AbstractPartyMember.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Party party;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">joinParty</span><span class="params">(Party party)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125;加入了派对"</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.party = party;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != activity) &#123;</span><br><span class="line">      LOGGER.info(<span class="string">"&#123;&#125;提议进行&#123;&#125;活动"</span>, <span class="keyword">this</span>, activity);</span><br><span class="line">      party.letAct(<span class="keyword">this</span>, activity);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">partyActivity</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"进行派对活动，名称：&#123;&#125;，介绍：&#123;&#125;"</span>, activity, activity.getDescription());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>派对中提供的活动有射击、猜灯谜、桌游和唱歌，为其定义一个枚举类</p><p>Activity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Activity &#123;</span><br><span class="line">  SHOOT(<span class="string">"射击"</span>, <span class="string">"Shooting"</span>), GUESS(<span class="string">"猜灯谜"</span>, <span class="string">"Guess"</span>), DESKTOP_GAME(<span class="string">"桌游"</span>, <span class="string">"Desktop games"</span>), SING(<span class="string">"唱歌"</span>, <span class="string">"singing"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">  Activity(String name, String description) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.description = description;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> description;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有四种不同职业或特点的参与者，分别继承自 <code>AbstractPartyMember</code> 类，分别覆盖了父类中的 <code>toString()</code> 方法来表示其特征</p><p>他们分别是 <code>Officer.java</code>,<code>Oldman.java</code>,<code>Student.java</code> 和 <code>Businessman.java</code>，此处省略具体代码</p><p>现在来举办一次派对，参与者们分别向派对举办者提出活动请求，举办者分别批准</p><p>App.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Application.class);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//   派对举办者</span></span><br><span class="line">    Party party = <span class="keyword">new</span> PartyImpl();</span><br><span class="line">    <span class="comment">// 学生</span></span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    <span class="comment">// 官员</span></span><br><span class="line">    Officer officer = <span class="keyword">new</span> Officer();</span><br><span class="line">    <span class="comment">// 商人</span></span><br><span class="line">    Businessman businessman = <span class="keyword">new</span> Businessman();</span><br><span class="line">    <span class="comment">// 老人</span></span><br><span class="line">    Oldman oldman = <span class="keyword">new</span> Oldman();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邀请成员加入</span></span><br><span class="line">    party.addMember(student);</span><br><span class="line">    party.addMember(officer);</span><br><span class="line">    party.addMember(businessman);</span><br><span class="line">    party.addMember(oldman);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别提出参加活动的请求</span></span><br><span class="line">    student.act(Activity.DESKTOP_GAME);</span><br><span class="line">    officer.act(Activity.GUESS);</span><br><span class="line">    businessman.act(Activity.SHOOT);</span><br><span class="line">    oldman.act(Activity.SING);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>需要使用中介者模式的场景是对象与对象之间存在大量的关联关系，这样下去会导致系统的结构变得复杂，一个对象的改动势必会影响到另一个与之关联的对象，，同时做出相应的改动，它们之间分别相互耦合，几乎形成了“网状”的结构，这对于复杂的系统是非常不利的。</p><p>中介者模式可以将这种 “网状结构” 解耦形成 “星形结构”，最典型的应用实例就是 MVC 结构，其中的 C （控制器） 就担当了 V（视图）和 M（模型）之间的中介者。</p><p>中介者模式的缺点是会使中介者对象异常复杂，降低了可维护性，所以应当尽量避免在对象间的职责划分比较难以界定的场景中使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中介者（Mediator）模式是用来降低多个对象和类之间的通信复杂性的。这种模式中通常提供一个充当中介者角色的类，用来承担“中心化”或“集中化”的职能，与各个对象之间都可以分别相互通信，它的一大优势是减少或避免其他对象之间的互相通信，在通信方面降低了耦合度。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记（12）迭代器</title>
    <link href="https://james.letec.top/2018/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://james.letec.top/2018/05/09/设计模式学习笔记（12）迭代器/</id>
    <published>2018-05-09T12:13:20.000Z</published>
    <updated>2018-05-11T13:23:33.790Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>迭代器（Iterator）模式又称游标模式，是集合类型对外提供统一的顺序访问元素而隐藏内部的实现细节的一种方式，是一种行为模式。<br><a id="more"></a><br>迭代器在 Java 的集合类中非常常见，我们使用迭代器来遍历集合中的每一个元素。迭代器在 ArrayList 的使用通常是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] array = <span class="keyword">new</span> String[]&#123;<span class="string">"百度"</span>, <span class="string">"阿里"</span>, <span class="string">"腾讯"</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">百度</span><br><span class="line">阿里</span><br><span class="line">腾讯</span><br></pre></td></tr></table></figure></p><p>我们使用 Iterator 接口的一个实例来访问这个 List 实例，Iterator 接口非常小巧，定义了两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否有后继元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取下一个元素的引用，执行此方法后，“游标”自动向后移动</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 中的“容器”类的之间的关系：</p><p><img src="https://upload-images.jianshu.io/upload_images/7134080-3bb3c992f92b829d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Collection 接口继承自 Iterable:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以理解为所有的集合都是可遍历的，因为集合就是一系列元素的“容器”。而 Collection 接口中的 iterator() 方法返回一个 Iterator 接口的引用，所以可以对所有的 Collection 的子类调用 iterator() 方法来获取这个容器实例的迭代器。对于不同的容器的实现，其内部数据结构是不同的，所以具体的迭代方式自然也不尽相同，但是它们都通过这个统一的接口方法来获取迭代器，迭代的实现被巧妙的隐藏了。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>现实生活中有一个常用的场景和迭代器的工作方式非常相似，那就是在图书馆中寻找自己想要的一本书，我们通常的做法是找到这个类目的书架，然后按一定的顺序一本一本的找，这个过程可以大致视为迭代器遍历书架这个容器。</p><p>我们把这个书架上的书分为三个大类：IT、小说和卡通，用一个枚举类来表示：</p><p>ItemType.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ItemType &#123;</span><br><span class="line">  IT, FICTION, CARTOON</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和 JDK 中提供给我们的 Iterator 接口类似，我们也定义一个 Iterator 接口：</p><p>ItemIterator.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Item <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个书架类 BookShelf，它持有一个 List<itemtype> 类型的引用，表示书架上所有图书的集合：</itemtype></p><p>BookShelf.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Item&gt; items;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BookShelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.FICTION, <span class="string">"西游记"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.FICTION, <span class="string">"水浒传"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.FICTION, <span class="string">"三国演义"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.FICTION, <span class="string">"红楼梦"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.CARTOON, <span class="string">"阿衰"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.CARTOON, <span class="string">"七龙珠"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.CARTOON, <span class="string">"火影忍者"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.IT, <span class="string">"设计模式-可复用面向对象软件的基础"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.IT, <span class="string">"重构-改善既有代码的设计"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.IT, <span class="string">"Effective Java"</span>));</span><br><span class="line">    items.add(<span class="keyword">new</span> Item(ItemType.IT, <span class="string">"Java编程思想"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Item&gt; <span class="title">getItemList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Item&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.addAll(items);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来定义专门为 BookShelf 服务的迭代器，它实现 ItemIterator 接口：</p><p>BookShelfIterator.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelfIterator</span> <span class="keyword">implements</span> <span class="title">ItemIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ItemType type;</span><br><span class="line">  <span class="keyword">private</span> BookShelf shelf;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BookShelfIterator</span><span class="params">(ItemType type, BookShelf shelf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    <span class="keyword">this</span>.shelf = shelf;</span><br><span class="line">    <span class="keyword">this</span>.idx = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> != getNexIdx();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    idx = getNexIdx();</span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> != idx) &#123;</span><br><span class="line">      <span class="keyword">return</span> shelf.getItemList().get(idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNexIdx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Item&gt; list = shelf.getItemList();</span><br><span class="line">    <span class="keyword">int</span> tempIdx = idx;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!found) &#123;</span><br><span class="line">      tempIdx++;</span><br><span class="line">      <span class="keyword">if</span> (tempIdx &gt;= list.size()) &#123;</span><br><span class="line">        tempIdx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (list.get(tempIdx).getType().equals(type)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempIdx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们间接的使用了 List 接口提供的方法 get() 来获取第 n 个元素，其内部实现同样被隐藏了，这里只是演示遍历的过程，因此不必考虑 List 的内部数据结构。</p><p>显然，这和 Collection 中的结构是不同的，BookShelfIterator 持有 BookShelf 的引用，而不是由 BookShelf 来生成适用于它自身的迭代器，虽然看起来比较别扭，不过还是符合实际情况的，迭代器要拿到书架这个对象才能遍历它。如果大范围的使用，还是应当仿照 Collection 中的设计思路，避免出现过多的类，给系统的复杂度造成负担。</p><p>现在拿一个装满书的书架来试一下这个迭代器的效果：</p><p>App.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Application.class);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找小说</span></span><br><span class="line">    ItemIterator iterator = <span class="keyword">new</span> BookShelfIterator(ItemType.FICTION, <span class="keyword">new</span> BookShelf());</span><br><span class="line">    LOGGER.info(<span class="string">"正在查找小说类图书"</span>);</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      Item nextItem = iterator.next();</span><br><span class="line">      LOGGER.info(<span class="string">"找到了符合条件的图书，书名为：&#123;&#125;"</span>, nextItem.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找IT</span></span><br><span class="line">    ItemIterator iterator2 = <span class="keyword">new</span> BookShelfIterator(ItemType.IT, <span class="keyword">new</span> BookShelf());</span><br><span class="line">    LOGGER.info(<span class="string">"正在查找IT类图书"</span>);</span><br><span class="line">    <span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">      Item nextItem = iterator2.next();</span><br><span class="line">      LOGGER.info(<span class="string">"找到了符合条件的图书，书名为：&#123;&#125;"</span>, nextItem.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找漫画</span></span><br><span class="line">    ItemIterator iterator3 = <span class="keyword">new</span> BookShelfIterator(ItemType.CARTOON, <span class="keyword">new</span> BookShelf());</span><br><span class="line">    LOGGER.info(<span class="string">"正在查找漫画类图书"</span>);</span><br><span class="line">    <span class="keyword">while</span> (iterator3.hasNext()) &#123;</span><br><span class="line">      Item nextItem = iterator3.next();</span><br><span class="line">      LOGGER.info(<span class="string">"找到了符合条件的图书，书名为：&#123;&#125;"</span>, nextItem.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>迭代器模式提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。迭代器模式关乎遍历集合的解决思路是把游标在元素之间移动的职责转交给迭代器，而不是集合对象自己。</p><p>迭代器模式的优点有：<br>1、它支持以不同的方式遍历一个集合合对象<br>2、迭代器模式简化了集合类<br>3、在同一个聚合上可以有多个遍历<br>4、使用迭代器模式，新建聚合类和迭代器，无须修改原有代码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;迭代器（Iterator）模式又称游标模式，是集合类型对外提供统一的顺序访问元素而隐藏内部的实现细节的一种方式，是一种行为模式。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记（11）解释器</title>
    <link href="https://james.letec.top/2018/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    <id>https://james.letec.top/2018/05/01/设计模式学习笔记（11）解释器/</id>
    <published>2018-05-01T08:11:10.000Z</published>
    <updated>2018-05-09T11:45:34.840Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>解释器（Interpreter）模式提供了校验语言的语法或表达式的途径，它属于行为型模式的一种。这种模式通常会提供一个表达式接口，通过这个接口可以解释对应特定环境的上下文。</p><p>解释器模式在日常开发的过程中不是很常用，但它在 SQL 解析、符号处理引擎、编译程序等场景中使用非常广泛。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>给定一个语言，解释器模式可以定义出其文法的一种表示,并定义一个解释器，该解释器使用该表示来解释语言中的句子。举个简单的例子，在某种计算器中输入 <code>5+1-3*2</code>，每输入一个字符，屏幕上都会显示当前的结果，和这种计算器不同的是另外一种，即一次性输入 <code>5+1-3*2</code> 然后点击 <code>=</code>，直接得出最终结果，后面这种计算器就用到了解释器。</p><p>我们输入的这一系列符号可以用二叉树的形式来表示，比如 <code>5+1-3*2</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/7134080-69cbcd75f8495529.png" alt=""></p><p>这个二叉树就是一个简单的语法树，在一般的计算机程序设计语言的编译过程中，通常都包含类似的语法树生成的过程。</p><p>图中的 <code>5</code>、 <code>1</code>、 <code>3</code>、 <code>2</code> 都叫做 <strong>终结符表达式</strong>，所谓终结符就是本身不能再推导出其他符号了，图中的 <code>+</code>、 <code>-</code>、 <code>*</code> 这些四则运算符号就是 <strong>非终结符表达式</strong> 了，因为可以由这些符号分别展开，形成各自的子表达式。对于四则运算表达式，解析的结果就是运算结果，所以运算符号可以抽象出一个接口，包含一个返回值为整数（假设只有整数参与运算）的 <code>interpret()</code> 方法。</p><p>Expression.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于加减乘除解释的出来的运算结果显然是不同的，所以分别实现这个接口形成四个类，四则运算符号需要左右两个操作数才能进行解释运算，所以每个运算符都持有两个符号的引用，分别作为其左运算数和右运算数：</p><p>加号，PlusExpression.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlusExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Expression expressionLeft;</span><br><span class="line">  <span class="keyword">private</span> Expression expressionRight;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PlusExpression</span><span class="params">(Expression expressionLeft, Expression expressionRight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.expressionLeft = expressionLeft;</span><br><span class="line">    <span class="keyword">this</span>.expressionRight = expressionRight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> expressionLeft.interpret() + expressionRight.interpret();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"+"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减号，MinusExpression.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinusExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Expression expressionLeft;</span><br><span class="line">  <span class="keyword">private</span> Expression expressionRight;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MinusExpression</span><span class="params">(Expression expressionLeft, Expression expressionRight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.expressionLeft = expressionLeft;</span><br><span class="line">    <span class="keyword">this</span>.expressionRight = expressionRight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> expressionLeft.interpret() - expressionRight.interpret();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"-"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乘号，MultipleExpression.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Expression expressionLeft;</span><br><span class="line">  <span class="keyword">private</span> Expression expressionRight;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MultipleExpression</span><span class="params">(Expression expressionLeft, Expression expressionRight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.expressionLeft = expressionLeft;</span><br><span class="line">    <span class="keyword">this</span>.expressionRight = expressionRight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> expressionLeft.interpret() * expressionRight.interpret();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"*"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除号，DivisionExpression.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivisionExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Expression expressionLeft;</span><br><span class="line">  <span class="keyword">private</span> Expression expressionRight;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DivisionExpression</span><span class="params">(Expression expressionLeft, Expression expressionRight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.expressionLeft = expressionLeft;</span><br><span class="line">    <span class="keyword">this</span>.expressionRight = expressionRight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> expressionLeft.interpret() / expressionRight.interpret();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个四则运算的算式，除了这四个四则运算符号，就是数字了，所以将数字抽象出一个数字符号类：</p><p>NumberExpression.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NumberExpression</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.number = number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NumberExpression</span><span class="params">(String numberString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.number = Integer.parseInt(numberString);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"数字"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上文中的算式用二叉树的形式表示，按顺序展开为一个字符序列，即 <code>- + * 5 1 3 2</code>，现在模仿计算器对其进行解释，这里用到了一点数据结构的知识，遍历二叉树通常采用 <strong>堆栈 (Stack)</strong> 结构来实现：</p><p>App.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Application.class);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      String tokenString = <span class="string">"- + * 5 1 3 2"</span>;</span><br><span class="line">      Stack&lt;Expression&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      String[] stringList = tokenString.split(<span class="string">" "</span>);</span><br><span class="line">      <span class="keyword">for</span> (String s : stringList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOperator(s)) &#123;</span><br><span class="line">          Expression expressionRight = stack.pop();</span><br><span class="line">          Expression expressionLeft = stack.pop();</span><br><span class="line">          LOGGER.info(<span class="string">"左操作数：&#123;&#125;，右操作数：&#123;&#125;"</span>, expressionLeft.interpret(), expressionRight.interpret());</span><br><span class="line">          Expression expression = getExpressionInstance(s, expressionLeft, expressionRight);</span><br><span class="line">          LOGGER.info(<span class="string">"操作符：&#123;&#125;"</span>, expression);</span><br><span class="line">          Expression result;</span><br><span class="line">          <span class="keyword">if</span> (expression != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = <span class="keyword">new</span> NumberExpression(expression.interpret());</span><br><span class="line">            LOGGER.info(<span class="string">"运算结果为：&#123;&#125;"</span>, result.interpret());</span><br><span class="line">            stack.push(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          NumberExpression expression = <span class="keyword">new</span> NumberExpression(s);</span><br><span class="line">          stack.push(expression);</span><br><span class="line">          LOGGER.info(<span class="string">"数字入栈：&#123;&#125;"</span>, expression.interpret());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断字符串是否为四则运算的操作符</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> s 待判断的字符串</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否为操作符</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOperator</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.equals(<span class="string">"+"</span>) || s.equals(<span class="string">"-"</span>) || s.equals(<span class="string">"*"</span>) || s.equals(<span class="string">"/"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据字符串生成四则运算表达式</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> s               字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> expressionLeft  左表达式</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> expressionRight 右表达式</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 四则运算表达式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getExpressionInstance</span><span class="params">(String s, Expression expressionLeft, Expression expressionRight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isOperator(s)) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"+"</span>: &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> PlusExpression(expressionLeft, expressionRight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"-"</span>: &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> MinusExpression(expressionLeft, expressionRight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"*"</span>: &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> MultipleExpression(expressionLeft, expressionRight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"/"</span>: &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> DivisionExpression(expressionLeft, expressionRight);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>解释器主要运用方式就是解释语法树的节点，它将语法解释规则和实现结构，将复杂的解释工作指派到不同的解释器对象中，是什么语法就由什么解释器来解释。对于一棵生成好的语法树，通常由根节点开始解释，不断递归，依次选择适合子节点的解释器来进行解释。</p><p>解释器的应用场景：</p><ul><li>当一个语言需要解释执行，并可以将该语言中的句子表示为一个抽象语法树的时候，例如 XML 文件或正则表达式</li><li>一些重复出现的问题可以用一种简单的语言来进行表达</li><li>一个语言的文法较为简单，比如四则运算</li><li>当执行效率不是关键和主要关心的问题时可考虑解释器模式，因为大量使用递归循环调用，随着语法的复杂程度加剧，解释器的执行效率会非常低</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_
      
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记（10）职责链</title>
    <link href="https://james.letec.top/2018/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89%E8%81%8C%E8%B4%A3%E9%93%BE/"/>
    <id>https://james.letec.top/2018/04/26/设计模式学习笔记（10）职责链/</id>
    <published>2018-04-26T12:21:10.000Z</published>
    <updated>2018-05-02T07:51:11.709Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>职责链（Chain of Responsibility 亦译作 “责任链”）模式中，行为型模式的一种。它的具体特征是，几乎每个行为的实现者都持有职责链中下一个行为实现者的引用，在一个实现者无法完成指派给它的职责的时候，它就会将这一职责的请求传递给下一个实现者，多个传递关系就构成了一条职责链。</p><a id="more"></a><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>在一场海上演习中，作战指挥官负责把控全局，指挥协调舰队的各部分。指挥官发出指挥命令后，命令在各部门传递执行的过程就是一条职责链。比如，命令全体炮手做好开炮的准备，职责链就是这样的：指挥官-&gt;舰长-&gt;枪炮长-&gt;炮手，用序列图表示就是这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/7134080-2d5dc38288cbf3b0.png" alt="2018-04-27_135628.png"></p><p>按照 OOP 的惯例，我们又要开始抽象了，将责任链上的传递的消息进行抽象，形成一个 Request 类。指挥官会发布一系列类型的命令，包括行进、停止和射击，每个命令还包括一些其他的描述，比如命令的具体参数等。</p><p>Request.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isHandled;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RequestType type;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">Request</span><span class="params">(String description, RequestType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.description = description;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHandled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isHandled;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHandled</span><span class="params">(<span class="keyword">boolean</span> handled)</span> </span>&#123;</span><br><span class="line">    isHandled = handled;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> description;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestType <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setHandled(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getDescription();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> RequestType &#123;</span><br><span class="line">    <span class="comment">// 射击</span></span><br><span class="line">    SHOOTING,</span><br><span class="line">    <span class="comment">// 航行</span></span><br><span class="line">    SAILING,</span><br><span class="line">    <span class="comment">// 待命</span></span><br><span class="line">    AWAIT_ORDERS</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，职责链上每个节点的类都应当至少实现同一个命令处理接口，这个接口只有一个方法即 “处理请求”，这里就是根据上一级领导的命令作出具体的动作,这里用抽象类来实现：</p><p>RequestHandler.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(RequestHandler.class);</span><br><span class="line">  <span class="keyword">private</span> RequestHandler next;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RequestHandler</span><span class="params">(RequestHandler next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != next) &#123;</span><br><span class="line">      next.handleRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printHandleMessage</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125;处理消息中，消息内容为：&#123;&#125;"</span>, <span class="keyword">this</span>, request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，这条职责链由谁来创建呢？如果这只队伍是指挥官组织起来的，那么当然要由指挥官来创建了，那么就有了这个指挥官类：</p><p>Commander.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Commander</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RequestHandler chain;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Commander</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    createChain();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    chain = <span class="keyword">new</span> Captain(<span class="keyword">new</span> Gunny(<span class="keyword">new</span> Gunner(<span class="keyword">null</span>)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    chain.handleRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指挥官通过三种级别的成员的构造方法，构造出一条完整的职责链，然后将命令发送给链上的第一个节点，那么这条命令就会逐级传递下去，最终被执行了。</p><p>App.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Commander commander = <span class="keyword">new</span> Commander();</span><br><span class="line"></span><br><span class="line">    commander.handleRequest(<span class="keyword">new</span> Request(<span class="string">"正常航行"</span>, Request.RequestType.SAILING));</span><br><span class="line">    commander.handleRequest(<span class="keyword">new</span> Request(<span class="string">"原地待命"</span>, Request.RequestType.AWAIT_ORDERS));</span><br><span class="line">    commander.handleRequest(<span class="keyword">new</span> Request(<span class="string">"发射驱逐导弹"</span>, Request.RequestType.SHOOTING));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>职责链模式在现实世界中的应用：</p><ul><li>Tomcat 服务器对编码的处理</li><li>Spring MVC 的拦截器</li><li>Servlet 的 Filter</li></ul><p>客户端发送给服务器的请求由 Filter（过滤器）进行预先处理，多个不同功能的 Filter 构成一条 FilterChian，请求经过这条 FilterChian 处理后最终到达 Servlet，在这里被最终处理。</p><p>职责链模式的侧重点在单个环节上，它不过多的关注其他行为实现者的特征。职责链上的每个节点都至少持有下一个实现者的引用，和数据结构中的 “链表” 类似，链上的消息具有单项传递性，这个节点任务完成后将消息发送给链上的下一个节点，依次传递下去，最终构成一条职责链。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;职责链（Chain of Responsibility 亦译作 “责任链”）模式中，行为型模式的一种。它的具体特征是，几乎每个行为的实现者都持有职责链中下一个行为实现者的引用，在一个实现者无法完成指派给它的职责的时候，它就会将这一职责的请求传递给下一个实现者，多个传递关系就构成了一条职责链。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记（9）命令</title>
    <link href="https://james.letec.top/2018/04/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89%E5%91%BD%E4%BB%A4/"/>
    <id>https://james.letec.top/2018/04/25/设计模式学习笔记（9）命令/</id>
    <published>2018-04-25T14:00:20.000Z</published>
    <updated>2018-04-26T06:52:51.012Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>命令（Command）模式是一种数据驱动的设计模式，它属于行为型模式。请求被包装成一个命令对象，并由调用者传递给被调用对象。被调用对象寻找可以处理该命令的合适的处理对象，并把该命令传给这个处理对象，该处理对象执行命令。</p><p>命令模式中，命令的发出者和接收者是独立的，发出命令的职责和处理命令的职责被分别指派给不同的对象。命令模式解决了一般的调用过程中，“行为请求者”与“行为实现者” 之间的强耦合关系。比如某些场合中，需要对命令进行“撤销”、“重做”，亦或其他不得不以 “事务” 的形式实现的场合，命令发出者和命令实现者之间的解耦就显得至关重要了。</p><a id="more"></a><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>命令模式最常见的场景就是字处理软件了，软件必须允许使用者进行重做或撤销的操作，仿佛没有这种特性的字处理软件几乎不会有人乐意使用。</p><p>首先不考虑使用命令模式，而是以传统的对象间调用来实现这种需求。假设我们现在需要对某个字依次进行如下操作：增大字号、设置字体颜色为红色、设置为加粗，那么对于命令发出者，要处理的逻辑就是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if(改变字号)&#123;</span><br><span class="line">    if(增大字号)&#123;</span><br><span class="line">        字号渲染器.增大字号();</span><br><span class="line">    &#125;else if(减小字号)&#123;</span><br><span class="line">        字号渲染器.减小字号();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if(改变颜色)&#123;</span><br><span class="line">    颜色渲染器.改变颜色(颜色);</span><br><span class="line">&#125;</span><br><span class="line">if(改变粗细)&#123;</span><br><span class="line">    if(加粗)&#123;</span><br><span class="line">        粗细渲染器.加粗();</span><br><span class="line">    &#125;else if(不加粗)&#123;</span><br><span class="line">        粗细渲染器.变细();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种 “紧耦合” 的结构下，行为请求者与行为实现者之间的关系大概是这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/7134080-2231f5ca9d53215b.png" alt=""></p><p>首先，所有命令都要有对应的处理者去执行，这就意味着行为请求者需要持有多个处理者的引用。这样，每修改或添加一个命令就必须修改行为请求者的逻辑，没办法实现对扩展开放。其次，如果要实现对命令的撤销或重做，那么本来就复杂的行为判断逻辑会变得愈发臃肿，对程序员来说这简直是一场灾难。</p><p>那么将行为请求者和行为实现者进行解耦后是怎样的呢？大概如图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7134080-da88d063aeded303.png" alt=""></p><p>将行为请求者和行为实现者解耦，直观的改变就是：行为请求者不会直接调用行为实现者的具体方法，而是向行为实现者发出包含行为的具体命令，这个命令通常以对象的形式出现，他们之间传递的消息就是命令模式中的核心元素 —— “命令”，他在原始的行为请求者和行为实现者之间架起了一条高速公路，原来臃肿的逻辑判断代码得到了缩减，逻辑判断的职责被指派给了行为实现者，而行为请求者只需专注于发出正确的命令。</p><p>为了将使行为请求者和行为的具体实现解耦，应当将命令进行抽象。继续上面字处理软件的例子，用户发出的命令应当至少包含 “撤销” 和 “重做” 的功能，因此我们可以这样设计 “命令” 抽象类：</p><p>Command.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 撤销</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 重做</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增大字体的命令：</p><p>Enlarge.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enlarge</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AbstractFont font;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Size oriSize;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Enlarge</span><span class="params">(AbstractFont font)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.font = font;</span><br><span class="line">    oriSize = font.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    font.setSize(Size.LARGE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    font.setSize(oriSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使字体变红：</p><p>Rubify.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rubify</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AbstractFont font;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Color oriColor;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Rubify</span><span class="params">(AbstractFont font)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.font = font;</span><br><span class="line">    oriColor = font.getColor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    font.setColor(Color.RED);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    font.setColor(oriColor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种命令的共同点是都继承自命令抽象类，并持有一个行为实施对象的引用，也就是说，行为的具体实现过程被封装到了每个具体的命令中。</p><p>那么现在就需要一个行为请求者来发出命令了：</p><p>Typist.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Typist</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Typist.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Deque&lt;Command&gt; redoStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Deque&lt;Command&gt; undoStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cast</span><span class="params">(Command command, AbstractFont font)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"&#123;&#125;正在处理字体，命令为：&#123;&#125;，处理的字体为：&#123;&#125;"</span>, <span class="keyword">this</span>, command, font);</span><br><span class="line">    command.execute();</span><br><span class="line">    undoStack.offerLast(command);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!undoStack.isEmpty()) &#123;</span><br><span class="line">      Command previousCommand = undoStack.pollLast();</span><br><span class="line">      redoStack.offerLast(previousCommand);</span><br><span class="line">      LOGGER.info(<span class="string">"&#123;&#125;正在进行撤销操作，命令为：&#123;&#125;"</span>, <span class="keyword">this</span>, previousCommand);</span><br><span class="line">      previousCommand.undo();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOGGER.info(<span class="string">"没有可以撤销的操作了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!redoStack.isEmpty()) &#123;</span><br><span class="line">      Command previousCommand = redoStack.pollLast();</span><br><span class="line">      undoStack.offerLast(previousCommand);</span><br><span class="line">      LOGGER.info(<span class="string">"&#123;&#125;正在进行重做操作，命令为：&#123;&#125;"</span>, <span class="keyword">this</span>, previousCommand);</span><br><span class="line">      previousCommand.redo();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOGGER.info(<span class="string">"没有可以重做的操作了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分别用两个队列来记录执行过的命令与撤销过的命令，“撤销” 操作对应 “已执行” 的操作， “重做” 操作对应 “已撤销” 的操作。每次执行命令，同时把命令放到 “撤销” 队列的队尾；同样的，每次执行 “撤销” 操作，也同时将命令放到 “重做” 队列的队尾。</p><p>为了方便 “观察” 字体的状态，我们将字体抽象成一个类：</p><p>AbstractFont.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFont</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(AbstractFont.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Size size;</span><br><span class="line">  <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Size <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(Size size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 打印当前状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"字体当前状态为：\t字体大小：&#123;&#125;\t颜色：&#123;&#125;"</span>, getSize(), getColor());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拉以为用户来试试这个字处理软件吧，我们在旁边观察字体的状态：</p><p>App.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Typist sizeTypist = <span class="keyword">new</span> Typist();</span><br><span class="line">    Typist colorTypist = <span class="keyword">new</span> Typist();</span><br><span class="line">    RegularScript font = <span class="keyword">new</span> RegularScript();</span><br><span class="line"></span><br><span class="line">    Command rubify = <span class="keyword">new</span> Rubify(font);</span><br><span class="line">    Command enlarge = <span class="keyword">new</span> Enlarge(font);</span><br><span class="line"></span><br><span class="line">    font.printStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置字体颜色</span></span><br><span class="line">    colorTypist.cast(rubify, font);</span><br><span class="line">    font.printStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置字体大小</span></span><br><span class="line">    sizeTypist.cast(enlarge, font);</span><br><span class="line">    font.printStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销颜色更改</span></span><br><span class="line">    colorTypist.undo();</span><br><span class="line">    font.printStatus();</span><br><span class="line">    colorTypist.undo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销大小更改</span></span><br><span class="line">    sizeTypist.undo();</span><br><span class="line">    font.printStatus();</span><br><span class="line">    sizeTypist.undo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字体颜色重做</span></span><br><span class="line">    colorTypist.redo();</span><br><span class="line">    font.printStatus();</span><br><span class="line">    colorTypist.redo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大小重做</span></span><br><span class="line">    sizeTypist.redo();</span><br><span class="line">    font.printStatus();</span><br><span class="line">    sizeTypist.redo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察到的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">小字，黑色</span><br><span class="line">小字，红色</span><br><span class="line">大字，红色</span><br><span class="line">大字，黑色</span><br><span class="line">小字，黑色</span><br><span class="line">大字，黑色</span><br><span class="line">大字，红色</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>命令模式的主要适用场景有：</p><ul><li>需要将行为请求者和行为实现者解耦，使得请求者和行为作用对象不直接交互</li><li>需要在不同的时间发出请求、使请求排队以及执行队列中的请求</li><li>需要支持命令的撤销操作和重做等类似操作</li><li>需要将一组操作组合在一起，即实现宏命令</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;命令（Command）模式是一种数据驱动的设计模式，它属于行为型模式。请求被包装成一个命令对象，并由调用者传递给被调用对象。被调用对象寻找可以处理该命令的合适的处理对象，并把该命令传给这个处理对象，该处理对象执行命令。&lt;/p&gt;
&lt;p&gt;命令模式中，命令的发出者和接收者是独立的，发出命令的职责和处理命令的职责被分别指派给不同的对象。命令模式解决了一般的调用过程中，“行为请求者”与“行为实现者” 之间的强耦合关系。比如某些场合中，需要对命令进行“撤销”、“重做”，亦或其他不得不以 “事务” 的形式实现的场合，命令发出者和命令实现者之间的解耦就显得至关重要了。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记（8）单例</title>
    <link href="https://james.letec.top/2018/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89%E5%8D%95%E4%BE%8B/"/>
    <id>https://james.letec.top/2018/04/22/设计模式学习笔记（8）单例/</id>
    <published>2018-04-22T02:23:20.000Z</published>
    <updated>2018-04-23T09:54:24.828Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>单例（Singleton）模式是最常用的设计模式之一，但同时也是最能体现 Java 特性的设计模式之一，它是创建型模式中最经典的一个。</p><p>单例模式的核心目的是，保证一个类的实例只存在一个。许多场景中整个软件系统只需要拥有一个该类的全局对象，这是为了更好的实现这个对象的功能。一个常见的场景，服务器应用程序中，某些配置通常放在若干个文件中，某个类的一个单例对象将配置读取进来，以后每次需要获取配置信息只需要通过单例模式的风格获取这个对象，就能得到这些配置数据了。相反，如果每次需要获取配置信息都要 <code>new</code> 一个该类的对象并读取配置文件，那将造成许多本可以避免的性能开销。</p><a id="more"></a><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>单例模式的应用场景理解起来比较简单，就不举具体的例子了，我们来看几种常用的单例写法：</p><p>先来看最简单的，这里的 <code>Singleton</code>类只是为了演示单例的写法，实际中它还应当实现某些功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Single();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写完后，每次需要获取 <code>Singleton</code> 类的实例，就调用 <code>Singleton.getInstance()</code> 这个方法。这样写对于一般的使用是可以了，但并不能完全保证 <code>Singleton</code> 类的对象只存在一个，因为我们可以手动调用 <code>Singleton</code> 类的构造方法来实例化出一个 <code>Singleton</code> 对象。那么如何避免这个问题呢？一个常用的方法就是将 <code>Singleton</code> 类的构造方法私有化，使得它的构造方法防止被外部的类调用，即只能由自己的静态方法实例化自己:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看一下方法，每次获取实例对象之前先进行判空，如果对象为 <code>null</code> 则实例化一个 <code>instance</code>，如果存在则直接返回该实例。这种方法的看似是完美的，即看似实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种写法的使用结果就不是能保证单例了。</p><p>为了保证只有一个线程，需要引入一个关键字 <code>synchronized</code>，它的作用是给其修饰的方法加上一把同步锁，当访问带有这个关键字的方法时，其他访问该方法的线程都会进入阻塞状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这样写可以保证该类的实例只存在一个，但是这会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率。所以这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，只有当判断 <code>instance</code> 为 <code>null</code> 的时候才执行内层的同步代码块，同步代码块中的判空保证了不会产生多个实例。这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重排，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;          <span class="comment">//A</span></span><br><span class="line">a = <span class="number">3</span>;          <span class="comment">//B</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;      <span class="comment">//C</span></span><br><span class="line"><span class="keyword">int</span> c = a + b;  <span class="comment">//D</span></span><br></pre></td></tr></table></figure><p>可能会被重排成 A-C-B-D 或者 C-A-B-D，显然，重排之后是不影响程序最终的执行结果的，至于它究竟是如何提高运行效率的，我们暂时不考虑。回到 <code>Singleton</code> 的例子中， <code>instance</code> 对象势必会存在这样一种状态，即：已经为其分配了内存空间，但是并没有调用其构造方法进行实例化，就像上面代码中，语句 C 如果是判空，那么初始化就是语句 B，假如语句 C 赶在语句 B 之前执行了，a 确实不为空，但返回 a 一定会产生一个异常，因为它还没有被真正的初始化。</p><p>于是，诞生了终极写法 —— 引入 <code>volatile</code> 关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile 关键字具有屏蔽指令重排的作用，即对 <code>instance</code> 加上了一把锁，在完成写操作之前不会允许其他线程对其进行任何读操作，即每次读取的内容都时实时的。因此，在初始化完成前，无法对其进行读操作，也就不会判断它是 <code>null</code> 了。</p><p>最后抛出一个神奇的方法，利用枚举类线程安全的特点，使用枚举类代替 <code>class</code>，这样使用起来不用考虑多线程的问题，是最方便的一种写法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过枚举类获取单例的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Singleton result = Singleton.INSTANCE;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单例模式写法的要点：</p><ul><li>构造方法私有化</li><li>私有静态引用指向该类的实例</li><li>公有静态方法返回自己类的实例</li></ul><p>单例模式的应用场景主要有：</p><ul><li>一个类频繁的被实例化，但同时又频繁的被销毁</li><li>一个类的实例化过程非常耗费资源，且该类的对象频繁的被使用</li><li>类中的方法调用结果和类的状态有关</li><li>需要频繁访问网络、数据库或文件的类</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;单例（Singleton）模式是最常用的设计模式之一，但同时也是最能体现 Java 特性的设计模式之一，它是创建型模式中最经典的一个。&lt;/p&gt;
&lt;p&gt;单例模式的核心目的是，保证一个类的实例只存在一个。许多场景中整个软件系统只需要拥有一个该类的全局对象，这是为了更好的实现这个对象的功能。一个常见的场景，服务器应用程序中，某些配置通常放在若干个文件中，某个类的一个单例对象将配置读取进来，以后每次需要获取配置信息只需要通过单例模式的风格获取这个对象，就能得到这些配置数据了。相反，如果每次需要获取配置信息都要 &lt;code&gt;new&lt;/code&gt; 一个该类的对象并读取配置文件，那将造成许多本可以避免的性能开销。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记（7）原型</title>
    <link href="https://james.letec.top/2018/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89%E5%8E%9F%E5%9E%8B/"/>
    <id>https://james.letec.top/2018/04/21/设计模式学习笔记（7）原型/</id>
    <published>2018-04-21T06:32:00.000Z</published>
    <updated>2018-04-26T06:52:52.824Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>原型（Prototype）模式用于创建重复的对象，与工厂模式类似。它们之间的区别是：工厂模式通过 <code>new</code> 关键字调用类的构造方法来创建对象，而原型模式采用复制已存在对象的方式创建新的对象。如果通过构造方法创建对象会造成一定程度上的性能问题，就应当考虑使用原型模式。例如，一个对象需在创建时需要进行读数据库的操作，并且这个对象需要被频繁的创建，那么就应当采用缓存的方式，在数据不更新的前提下，尽可能的使用缓存，也就是克隆的对象。</p><a id="more"></a><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>在 Java 中，原型模式一般通过 <code>java.lang.Object</code> 类提供的 <code>clone()</code> 方法来实现，那么我们就很容易联想到生物上的克隆技术了，最耳熟能详的成果就是克隆羊多利，那就以羊举例。首先定义 <code>Sheep</code> 类：</p><p>Sheep.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Sheep implements Cloneable &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Sheep <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sheep(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Sheep</code> 类通过重写父类 <code>Object</code> 提供的 <code>clone()</code> 方法创建一个新的 <code>Sheep</code> 实例，下面就试试这个克隆方法：</p><p>App.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">Sheep origin = <span class="keyword">new</span> Sheep(<span class="string">"团团"</span>);</span><br><span class="line">System.out.println(origin.getName());   </span><br><span class="line"><span class="comment">//&gt; 团团</span></span><br><span class="line"></span><br><span class="line">origin.setName(<span class="string">"圆圆"</span>);</span><br><span class="line">Sheep clone = origin.clone();</span><br><span class="line">System.out.println(clone.getName());    </span><br><span class="line"><span class="comment">//&gt; 圆圆</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用原型模式可以避免由于创建新的对象造成的性能开销，尽量使用克隆的方式创建新的对象。<br>原型模式适用于这些场景：</p><ul><li>当一个系统应该独立于它的产品创建，构成和表示时</li><li>当要实例化的类是在运行时指定时，例如，通过动态装载</li><li>为了避免创建一个与产品类层次平行的工厂类层次时</li><li>当一个类的实例只能有几个不同状态组合中的一种时，建立相应数目的原型并用他们克隆，这会比每次用具体的状态手动实例化更方便</li></ul><p>另外，<code>java.lang.Object</code> 类中的 <code>clone()</code> 方法是 <strong>native 方法</strong>，因此执行效率较高</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原型（Prototype）模式用于创建重复的对象，与工厂模式类似。它们之间的区别是：工厂模式通过 &lt;code&gt;new&lt;/code&gt; 关键字调用类的构造方法来创建对象，而原型模式采用复制已存在对象的方式创建新的对象。如果通过构造方法创建对象会造成一定程度上的性能问题，就应当考虑使用原型模式。例如，一个对象需在创建时需要进行读数据库的操作，并且这个对象需要被频繁的创建，那么就应当采用缓存的方式，在数据不更新的前提下，尽可能的使用缓存，也就是克隆的对象。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记（6）工厂方法</title>
    <link href="https://james.letec.top/2018/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    <id>https://james.letec.top/2018/04/20/设计模式学习笔记（6）工厂方法/</id>
    <published>2018-04-20T04:32:00.000Z</published>
    <updated>2018-04-20T13:30:43.931Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>工厂方法（Factory Method)模式，又叫做虚拟构造（Virtual Constructor）模式或多态工厂(Polymorphic Factory）模式。工厂方法的特点是定义一个用于创建对象的接口， 让子类决定实例化哪一个类。 工厂方法使一个类的实例化延迟到其子类。</p><a id="more"></a><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>这次以顾客点餐为例，假设有两个厨师，一个只会做中餐，另一个只会做西餐，餐品分为熟食和生食两类。顾客需要顾客需要根据自己的口味来选择对应的厨师并告知其需要熟食还是生食，厨师根据顾客的口味来进行烹制。</p><p>厨师的职责就是烹制食物，所以定义一个厨师接口</p><p>Cook.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">  <span class="function">Food <span class="title">cookFood</span><span class="params">(FoodType foodType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在简单的将食物赋予一个表示“冷或热”的属性，用枚举类型表示</p><p>FoodType.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FoodType &#123;</span><br><span class="line">  HOT(<span class="string">"热的"</span>), COLD(<span class="string">"凉的"</span>);</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  FoodType(String foodType) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = foodType;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义食物接口</p><p>Food.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">  <span class="function">FoodType <span class="title">getFoodType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>食物有中餐和西餐之分，分别定义两个食物接口的实现类</p><p>ChineseFood.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFood</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> FoodType foodType;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ChineseFood</span><span class="params">(FoodType foodType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foodType = foodType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> FoodType <span class="title">getFoodType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foodType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foodType.getName() + <span class="string">"中餐"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WesternFood.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WesternFood</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> FoodType foodType;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">WesternFood</span><span class="params">(FoodType foodType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foodType = foodType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> FoodType <span class="title">getFoodType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foodType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foodType.getName() + <span class="string">"西餐"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中餐厨师和西餐厨师分别烹制中餐和西餐，定义两个厨师接口的实现类</p><p>ChineseCook.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseCook</span> <span class="keyword">implements</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Food <span class="title">cookFood</span><span class="params">(FoodType foodType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ChineseFood(foodType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>WesternCook.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WesternCook</span> <span class="keyword">implements</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Food <span class="title">cookFood</span><span class="params">(FoodType foodType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WesternFood(foodType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“食物”产品的生产现在交给了“厨师工厂”来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cook cook1 = <span class="keyword">new</span> WesternCook();</span><br><span class="line">Cook cook2 = <span class="keyword">new</span> ChineseCook();</span><br><span class="line">Food food1 = cook1.cookFood(FoodType.COLD);</span><br><span class="line">Food food2 = cook2.cookFood(FoodType.HOT);</span><br></pre></td></tr></table></figure><p>本例只是单纯的演示工厂方法，因为对于这几个类而言，显然使用工厂方法模式比直接使用 <code>new</code> 关键字调用构造方法来说要复杂多了，所以简单对象的创建无需引入工厂模式，从而避免给系统带来更高的复杂度。</p><h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p>Java 的集合是一套优秀的数据结构设计，大部分集合类型都实现 <code>java.util.Collection</code> 接口，这个接口的父接口 <code>Iterable</code> 接口规定了所有的 Java 集合都必须提供一个 <code>iterator()</code> 方法，返还一个<code>Iterator</code> 类型的对象：</p><p>java.lang.Iterable.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ArrayList</code> 是我们常用的一个 <code>Collection</code> 接口实现类，其 <code>iterator()</code> 方法实现如下：</p><p>java.util.ArrayList.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 返回一个 Iterator 对象，工厂方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，<code>ArrayList</code> 中的 <code>iterator()</code> 方法是具体工厂类的工厂方法，而 <code>Collection</code> 就是一个工厂接口。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在基于类的设计中，工厂方法模式通常作为创建模式来使用。它使用工厂方法来处理创建对象的过程，无需指定创建对象的确切类型。客户端通过调用工厂方法来创建对象，这里的方法是在接口中指定的，或是由子类实现的，或是由基类实现，或者通过子类进行方法覆盖，从头至尾无需调用具体类的构造方法。</p><p>工厂方法模式就是为了完全满足“开闭原则”，在上文点餐的例子中，当增加食物类型的时候，无需改动现有的代码，只要增加一个能够完成新类型食物烹饪工作的厨师类即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;工厂方法（Factory Method)模式，又叫做虚拟构造（Virtual Constructor）模式或多态工厂(Polymorphic Factory）模式。工厂方法的特点是定义一个用于创建对象的接口， 让子类决定实例化哪一个类。 工厂方法使一个类的实例化延迟到其子类。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记（5）抽象工厂</title>
    <link href="https://james.letec.top/2018/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    <id>https://james.letec.top/2018/04/20/设计模式学习笔记（5）抽象工厂/</id>
    <published>2018-04-20T02:32:00.000Z</published>
    <updated>2018-04-20T08:44:11.230Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>抽象工厂模式是在工厂方法模式之上的有一次升级，以便能够处理更加复杂的对象创建场景。因此也是所有形态的工厂模式中最为抽象和最具一般性的一种形态。工厂 ( Factory ) 和产品 ( Product ) 是 Abstract Factory 模式的主要参与者。 该模式描述了怎样在不直接实例化类的情况下创建一系列相关的产品对象。 它最适用于产品对象的数目和种类不变， 而具体产品系列之间存在不同的情况。 我们通过实例化一个特定的具体工厂对象来选择产品系列， 并且以后一直使用该工厂生产产品对象。 我们也能够通过用一个不同的具体工厂实例来替换原来的工厂对象以改变整个产品系列。 抽象工厂模式对产品系列的强调使它区别于其他只与一种产品对象有关的创建性模式。</p><a id="more"></a><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>设想这样一种情景，一支远洋的队伍由船、船长以及水手组成，队伍有新人队伍和老兵队伍之分。新人的队伍有新船长、新水手以及崭新的船只；而老兵的队伍有老船长、经验丰富的老水手以及破旧的船只。不同队伍有着不同的特点，队伍中不同的部分之间存在一定的依赖。</p><p>首先定义“成员”接口，规定每个成员都可以描述自己的特性：</p><p>Member.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种具体成员的接口，它们都继承了“成员”接口:</p><p>Captain.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Captain</span> <span class="keyword">extends</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sailor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sailor</span> <span class="keyword">extends</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ship.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ship</span> <span class="keyword">extends</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就是一个抽象工厂，它描述了如何“生产”一支队伍：</p><p>TeamFactory.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TeamFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Ship <span class="title">createShip</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Captain <span class="title">createCaptain</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Sailor <span class="title">createSailor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种不同的队伍工厂分别“生产”不同特性的队伍：</p><p>YoungTeamFactory.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YoungTeamFactory</span> <span class="keyword">implements</span> <span class="title">TeamFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Ship <span class="title">createShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NewShip();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Captain <span class="title">createCaptain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> YoungCaptain();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Sailor <span class="title">createSailor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> YoungSailor();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PermanentTeamFactory.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermanentTeamFactory</span> <span class="keyword">implements</span> <span class="title">TeamFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Ship <span class="title">createShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OldShip();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Captain <span class="title">createCaptain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OldCaptain();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Sailor <span class="title">createSailor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OldSailor();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，一支队伍的“生产”就可以由这几步构成：创建具体特性的工厂，由工厂“生产”队伍：</p><p>App.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TeamFactory factory = <span class="keyword">new</span> YoungTeamFactory();</span><br><span class="line"></span><br><span class="line">Ship ship = factory.createShip();</span><br><span class="line">Captain = factory.createCaptain();</span><br><span class="line">Sailor = factory.createSailor();</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>抽象工厂的“抽象”指的就是：确定一个应用创建的对象的类，只关心生产什么产品而无需关注产品具体由哪些部件组成，更不需要关注产品具体是怎么生产出来的，它对某一类产品的生产过程制定了一个规则，所以抽象工厂并不关心具体组件的实现，而是只专注于接口。</p><p>关于抽象工厂模式和“开闭原则”：<br>如果需要重新组队，构成一支由新人和老人组成的混合队伍，那么只需要增加一种新的实现了 <code>TeamFactory</code> 接口的工厂即可，所以抽象工厂模式实现了“对扩展开放”。<br>但是，如果队伍中添加了一种新成员，比如“无线电操作员”，那么现有的所有接口都要跟着修改，所以它并没有实现“对修改关闭”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;抽象工厂模式是在工厂方法模式之上的有一次升级，以便能够处理更加复杂的对象创建场景。因此也是所有形态的工厂模式中最为抽象和最具一般性的一种形态。工厂 ( Factory ) 和产品 ( Product ) 是 Abstract Factory 模式的主要参与者。 该模式描述了怎样在不直接实例化类的情况下创建一系列相关的产品对象。 它最适用于产品对象的数目和种类不变， 而具体产品系列之间存在不同的情况。 我们通过实例化一个特定的具体工厂对象来选择产品系列， 并且以后一直使用该工厂生产产品对象。 我们也能够通过用一个不同的具体工厂实例来替换原来的工厂对象以改变整个产品系列。 抽象工厂模式对产品系列的强调使它区别于其他只与一种产品对象有关的创建性模式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记（4）构建者</title>
    <link href="https://james.letec.top/2018/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%E6%9E%84%E5%BB%BA%E8%80%85/"/>
    <id>https://james.letec.top/2018/04/20/设计模式学习笔记（4）构建者/</id>
    <published>2018-04-20T01:12:00.000Z</published>
    <updated>2018-04-20T06:08:28.859Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>构建者（Builder）模式通常用于将复杂对象的构造简化，将具体的构造过程与表示分离，使同样的构建过程可以创建不同的表示。使用多个简单的对象一步一步构建成一个复杂的对象，这种类型的设计模式属于创建型模式。建造模式可以将一个复杂对象的内部组成部分，与该对象本身的创建分离开来，从而使得复杂对象的组装更灵活。<br><a id="more"></a></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>设想一个场景，可以出现在游戏中，需要生成一个虚拟的人物模型，人物主要包括几个简单的属性：姓名、年龄、国籍以及肤色。假如一个数据模型的拥有很多属性，如果单纯使用构造方法来实例化对象，势必会造成构造方法参数爆炸的问题，也可以称之为“反可伸缩构造方法模式”。代码的可读性和可靠性大大降低。此时，可以为这个对象创建的过程指定一个创建者，我们只需要向创建者描述该对象的一些具体细节，接下来的构造过程就统统交给创建者完成了。</p><p>构建者模式要解决的主要问题就是“不可伸缩构造方法模式”，顾名思义，对象的构造方法固定且参数较多，构造对象的时候很容易搞错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Person(String name,Integer age,Nationality nationality,SkinColor skinColor...)&#123;...&#125;</span><br></pre></td></tr></table></figure><p>如果一直这样下去，随着属性的增多，构造方法的参数的数量也会变得越来越多，对于开发人员是非常头疼的。对属性的更改使得构造方法的维护难度增加了不少，这就是所谓的“反可伸缩构造方法模式”。</p><p>Person.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">  private final String name;</span><br><span class="line">  private final Integer age;</span><br><span class="line">  private final Nationality nationality;</span><br><span class="line"></span><br><span class="line">  public String getName() &#123;</span><br><span class="line">    return name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Integer getAge() &#123;</span><br><span class="line">    return age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Nationality getNationality() &#123;</span><br><span class="line">    return nationality;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public SkinColor getSkinColor() &#123;</span><br><span class="line">    return skinColor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private final SkinColor skinColor;</span><br><span class="line"></span><br><span class="line">  public Person(Builder builder) &#123;</span><br><span class="line">    this.name = builder.name;</span><br><span class="line">    this.age = builder.age;</span><br><span class="line">    this.skinColor = builder.skinColor;</span><br><span class="line">    this.nationality = builder.nationality;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static class Builder &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Nationality nationality;</span><br><span class="line">    private SkinColor skinColor;</span><br><span class="line"></span><br><span class="line">    public Builder age(Integer age) &#123;</span><br><span class="line">      this.age = age;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder name(String name) &#123;</span><br><span class="line">      if (null == name) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;人必须有名字!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      this.name = name;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder nationality(Nationality nationality) &#123;</span><br><span class="line">      this.nationality = nationality;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder skinColor(SkinColor skinColor) &#123;</span><br><span class="line">      this.skinColor = skinColor;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person build() &#123;</span><br><span class="line">      return new Person(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在就可以使用 Person.Builder 来构造一个 Person 对象了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person personWang = new Person.Builder()</span><br><span class="line">    .name(&quot;小王&quot;)</span><br><span class="line">    .age(25)</span><br><span class="line">    .nationality(Nationality.CHINA)</span><br><span class="line">    .skinColor(SkinColor.YELLOW)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>建造者模式通常适用于将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。主要解决在软件架构中，有时候会出现复杂对象的创建工作，解决思路是通常由各个部分的子对象用一定的方法构造而成。并且为了适应需求的变化，这个复杂对象的内容通常也会面临着频繁的变化，但是用子对象将它们组合在一起的方式就相对容易接受这种变化了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;构建者（Builder）模式通常用于将复杂对象的构造简化，将具体的构造过程与表示分离，使同样的构建过程可以创建不同的表示。使用多个简单的对象一步一步构建成一个复杂的对象，这种类型的设计模式属于创建型模式。建造模式可以将一个复杂对象的内部组成部分，与该对象本身的创建分离开来，从而使得复杂对象的组装更灵活。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记（3）装饰器</title>
    <link href="https://james.letec.top/2018/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://james.letec.top/2018/04/19/设计模式学习笔记（3）装饰器/</id>
    <published>2018-04-19T02:12:00.000Z</published>
    <updated>2018-05-13T08:18:54.141Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>装饰器（Decorator）模式用于动态地给一个对象添加一些额外的职责。 就增加功能来说， Decorator模式相比生成子类更为灵活。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。<br><a id="more"></a><br>纯粹的装饰模式很难找到，大多数的装饰模式的实现都是“半透明”的，而不是完全透明的。换言之，允许装饰模式改变接口，增加新的方法。半透明的装饰模式是介于装饰模式和适配器模式之间的。适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。                                                                                     大多数的装饰模式实际上是半透明的装饰模式，这样的装饰模式也称做半装饰、半适配器模式。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>以下情况使用Decorator模式</p><ul><li>在不影响其他对象的情况下， 以动态、 透明的方式给单个对象添加职责。</li><li>处理那些可以撤消的职责。</li><li>当不能采用生成子类的方法进行扩充时。 一种情况是， 可能有大量独立的扩展， 为支持每一种组合将产生大量的子类， 使得子类数目呈爆炸性增长。 另一种情况可能是因为类定义被隐藏， 或类定义不能用于生成子类。</li></ul><h2 id="模式要点"><a href="#模式要点" class="headerlink" title="模式要点"></a>模式要点</h2><p><img src="https://raw.githubusercontent.com/JamesZBL/java_design_patterns/master/decorator/uml/Decorator.png" alt=""></p><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ul><li>Component：定义一个对象接口， 可以给这些对象动态地添加职责。</li><li>ConcreteComponent：定义一个对象， 可以给这个对象添加一些职责。</li><li>Decorator：持有一个指向 Component 对象的引用，并定义一个与 Component 接口一致的接口。</li><li>ConcreteDecorator：一向组件添加职责。</li></ul><h3 id="协作原理"><a href="#协作原理" class="headerlink" title="协作原理"></a>协作原理</h3><ul><li>Decorator 将请求转发给它的 Component 对象， 并有可能在转发请求前后执行一些附加的动作。</li></ul><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src="https://raw.githubusercontent.com/JamesZBL/java_design_patterns/master/decorator/uml/Decorator_impl.png" alt=""></p><p>铁匠和木匠同时制作一把铁锤，第一种方案是木匠制作锤把，铁匠制作锤头；第二中方案是铁匠先制作锤把再制作锤头（假定这里的木匠只会制作锤把）。制作过程分为三部分：1.对材料进行初步的检查，2.进行制造并把部件安装起来以供后面的操作，3.完成之后再次进行检查，确保没有质量问题。</p><p>首先定义“操作”接口，包括前后两次检查以及安装的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流水线上操作行为的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">checkBefore</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">chekcAfter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在只由木匠制作锤把，定义一个木匠的操作类 CarpenterOperation<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 木匠的工作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarpenterOperation</span> <span class="keyword">implements</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(CarpenterOperation.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"检查木材"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"打造锤把"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chekcAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"检查成品锤把"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于某些原因，铁匠决定自己制作锤把，现在铁匠身兼双职，将木匠的工作也承担了。定义一个铁匠操作类 HammerSmith<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 铁匠</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HammerSmithOperation</span> <span class="keyword">implements</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(HammerSmithOperation.class);</span><br><span class="line">  <span class="keyword">private</span> Operation previousOperation;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HammerSmithOperation</span><span class="params">(Operation previousOperation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.previousOperation = previousOperation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    previousOperation.checkBefore();</span><br><span class="line">    LOGGER.info(<span class="string">"检查铁材"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    previousOperation.join();</span><br><span class="line">    LOGGER.info(<span class="string">"打造锤头"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chekcAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    previousOperation.chekcAfter();</span><br><span class="line">    LOGGER.info(<span class="string">"检查成品锤头"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样实现了“操作”的接口，铁匠的每个操作都包含了木匠相应的操作，相当于对木匠的操作增加了一层包裹和扩展。这种包装就是 Decorator 模式中的装饰。</p><p>现在分别让木匠和铁匠进行一系列操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decorator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Application.class);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"仅由木匠制作锤把"</span>);</span><br><span class="line">    Operation carpenter = <span class="keyword">new</span> CarpenterOperation();</span><br><span class="line">    carpenter.checkBefore();</span><br><span class="line">    carpenter.join();</span><br><span class="line">    carpenter.chekcAfter();</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">"由铁匠完成锤把以及锤头的制作"</span>);</span><br><span class="line">    Operation hammerSmith = <span class="keyword">new</span> HammerSmithOperation(carpenter);</span><br><span class="line">    hammerSmith.checkBefore();</span><br><span class="line">    hammerSmith.join();</span><br><span class="line">    hammerSmith.chekcAfter();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">仅由木匠制作锤把</span><br><span class="line">检查木材</span><br><span class="line">打造锤把</span><br><span class="line">检查成品锤把</span><br><span class="line"></span><br><span class="line">由铁匠完成锤把以及锤头的制作</span><br><span class="line">检查木材</span><br><span class="line">检查铁材</span><br><span class="line">打造锤把</span><br><span class="line">打造锤头</span><br><span class="line">检查成品锤把</span><br><span class="line">检查成品锤头</span><br></pre></td></tr></table></figure></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>装饰模式和静态继承的机制的作用都是对现有的类增加新的功能，但装饰模式有着比静态继承更灵活的组合方式。装饰模式可以在运行的时候决定需要增加还是去除一种“装饰”以及什么“装饰”。静态继承则没有这样的灵活性，它对类功能的扩展是在运行之前就确定了的。</li><li>得益于装饰模式在组合上的灵活性和便利性，我们可以将各种装饰类进行组合，从而较为简单的创造各种不同的行为集合，实现多种多样的功能。<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li><li>装饰者的对象和它装饰的对象本质上是完全不同的，装饰模式会生成许多的对象，导致区分各种对象变得困难</li><li>由于使用相同的标识，对于程序的理解和排错过程的难度也会随之增加</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;装饰器（Decorator）模式用于动态地给一个对象添加一些额外的职责。 就增加功能来说， Decorator模式相比生成子类更为灵活。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记（1）组合</title>
    <link href="https://james.letec.top/2018/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E7%BB%84%E5%90%88/"/>
    <id>https://james.letec.top/2018/04/17/设计模式学习笔记（1）组合/</id>
    <published>2018-04-17T01:12:00.000Z</published>
    <updated>2018-04-20T06:11:22.242Z</updated>
    
    <content type="html"><![CDATA[<p>本文实例代码：<a href="https://github.com/JamesZBL/java_design_patterns" target="_blank" rel="noopener">https://github.com/JamesZBL/java_design_patterns</a></p><p>组合（Composite）模式用于将对象组合成树形结构以表示 “部分——整体” 的层次结构。它使得用户对单个对象和组合对象的使用具有一致性。<br><a id="more"></a></p><h2 id="模式要点"><a href="#模式要点" class="headerlink" title="模式要点"></a>模式要点</h2><p><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd45454f35913c?w=984&amp;h=599&amp;f=png&amp;s=48305" alt=""></p><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ul><li>Component : 是组合中的所有对象的统一接口；定义了特定情况下，类应当实现的货缺省的行为；Component 声明一个接口用于访问和管理 Component 的子组件；在递归结构中定义一个接口，用于访问一个父部件，并符合条件的类中实现它，当然这个是可选的。</li><li>Leaf：在组合中表示叶节点对象，顾名思义，叶节点没有子节点。</li><li>Composite：定义有子部件的那些部件的行为，同时存储子部件，实现 Component 中与子部件有关的接口。</li><li>Client：通过Component接口，操纵组合部件的对象。<h3 id="协作原理"><a href="#协作原理" class="headerlink" title="协作原理"></a>协作原理</h3></li><li>用户使用Component类接口与组合结构中的对象进行交互。 如果接收者是一个叶节点，则直接处理请求。 如果接收者是Composite， 它通常将请求发送给它的子部件， 在转发请求之前与/或之后可能执行一些辅助操作。</li></ul><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>在中文中，一句话是由词语组成的，而词语又由字组成；在英文中，句子由单词组成，而单词又由一个个字母组成。每个对象都可定义的它之前的或之后的内容。比如一个中文句子总是以句号结尾，一个英文单词之前通常是有空格的。这种结构可以形成了递归嵌套的结构，句子是父容器，单词是子容器，字母是叶节点。<br><img src="https://user-gold-cdn.xitu.io/2017/11/19/15fd453dc4bcfe14?w=1526&amp;h=376&amp;f=png&amp;s=39695" alt=""><br>CharacterComposite 是一个抽象类，定义了所有容器类或叶节点的接口，容器应当实现的功能有：获取子组件、对子组件进行计数、定义组件的格式化输出规则。Sentence(句子) 和 Word (单词)都属于容器，而 Character (字母)则属于叶节点，因为字母中无法再添加子组件了，它是层次结构中的最末端。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有容器的抽象父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterComposite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;CharacterComposite&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(CharacterComposite character)</span> </span>&#123;</span><br><span class="line">    children.add(character);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.children.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    printBefore();</span><br><span class="line">    <span class="keyword">for</span> (CharacterComposite item : children) &#123;</span><br><span class="line">      item.print();</span><br><span class="line">    &#125;</span><br><span class="line">    printAfter();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>EnglishWord 组件前应当输出一个空格，EnglishSentence 组件后应当输出一个“.”，ChineseSentence 组件后应当输出一个“。”等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 英文句子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnglishSentence</span> <span class="keyword">extends</span> <span class="title">CharacterComposite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">EnglishSentence</span><span class="params">(List&lt;EnglishWord&gt; words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (EnglishWord word : words) &#123;</span><br><span class="line">      add(word);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 英文单词</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnglishWord</span> <span class="keyword">extends</span> <span class="title">CharacterComposite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">EnglishWord</span><span class="params">(List&lt;Character&gt; characters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Character c : characters) &#123;</span><br><span class="line">      add(c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Word 作为 Sentence 的子容器，Character 作为 Word 的子组件，属于叶节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字母</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Character</span> <span class="keyword">extends</span> <span class="title">CharacterComposite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Character</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.c = c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Writer 为句子生成器，各个组件及子组件均由它负责填充，最终形成一个完成的结构。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 语句生成器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CharacterComposite <span class="title">sentenceByChinese</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;ChineseWord&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    words.add(<span class="keyword">new</span> ChineseWord(Arrays.asList(<span class="keyword">new</span> Character(<span class="string">'我'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> ChineseWord(Arrays.asList(<span class="keyword">new</span> Character(<span class="string">'是'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> ChineseWord(Arrays.asList(<span class="keyword">new</span> Character(<span class="string">'来'</span>), <span class="keyword">new</span> Character(<span class="string">'自'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> ChineseWord(Arrays.asList(<span class="keyword">new</span> Character(<span class="string">'北'</span>), <span class="keyword">new</span> Character(<span class="string">'京'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> ChineseWord(Arrays.asList(<span class="keyword">new</span> Character(<span class="string">'的'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> ChineseWord(Arrays.asList(<span class="keyword">new</span> Character(<span class="string">'小'</span>), <span class="keyword">new</span> Character(<span class="string">'明'</span>))));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ChineseSentence(words);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CharacterComposite <span class="title">sentenceByEnglish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;EnglishWord&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    words.add(<span class="keyword">new</span> EnglishWord(Arrays.asList(<span class="keyword">new</span> Character(<span class="string">'I'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> EnglishWord(Arrays.asList(<span class="keyword">new</span> Character(<span class="string">'a'</span>), <span class="keyword">new</span> Character(<span class="string">'m'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> EnglishWord(Arrays.asList(<span class="keyword">new</span> Character(<span class="string">'a'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> EnglishWord(Arrays.asList(<span class="keyword">new</span> Character(<span class="string">'s'</span>), <span class="keyword">new</span> Character(<span class="string">'t'</span>), <span class="keyword">new</span> Character(<span class="string">'u'</span>), <span class="keyword">new</span> Character(<span class="string">'d'</span>), <span class="keyword">new</span> Character(<span class="string">'e'</span>), <span class="keyword">new</span> Character(<span class="string">'n'</span>), <span class="keyword">new</span> Character(<span class="string">'t'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> EnglishWord(Arrays.asList(<span class="keyword">new</span> Character(<span class="string">'f'</span>), <span class="keyword">new</span> Character(<span class="string">'r'</span>), <span class="keyword">new</span> Character(<span class="string">'o'</span>), <span class="keyword">new</span> Character(<span class="string">'m'</span>))));</span><br><span class="line">    words.add(<span class="keyword">new</span> EnglishWord(Arrays.asList(<span class="keyword">new</span> Character(<span class="string">'L'</span>), <span class="keyword">new</span> Character(<span class="string">'o'</span>), <span class="keyword">new</span> Character(<span class="string">'n'</span>), <span class="keyword">new</span> Character(<span class="string">'d'</span>), <span class="keyword">new</span> Character(<span class="string">'o'</span>), <span class="keyword">new</span> Character(<span class="string">'n'</span>))));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EnglishSentence(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ul><li>Composite 模式定义了基本对象和组合对象的基本层次结构，基本对象可以组合形成更复杂的对象，这个对象还可以再次进行组合，依次类推，可以实现无限层的递归嵌套结构，上文中提到的句子-单词-字母结构即是如此。</li><li>所有的容器都是这个接口的实现，用户可以一致地使用组合结构和单个对象，用户不需要知道它是否为叶节点或包含子容器的一个组件，从而大大简化了代码结构，定义组合的类时避免了各种复杂的包含着大量判断的方法。</li><li>在增加新的组件的时候更简单，无论是新增一种容器或一个叶节点都很方便，无需单独再定义新类并且可以很容易和现有的组件或容器结合工作，客户端无需随新组件的增加而做任何改变</li><li>使代码结构更具通用性，但也存在一些问题。增加组件很方便，但无法对子组件做过多的限制，即使客户希望在容器中只增加某种特定的组件，由于使用 Composite 而无法依靠别的类做过多的约束，这些检验类型的工作就要放到运行时去做了</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>你想表示对象的部分-整体层次结构</li><li>你希望用户忽略组合对象与单个对象的不同， 用户将统一地使用组合结构中的所有对象</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文实例代码：&lt;a href=&quot;https://github.com/JamesZBL/java_design_patterns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/JamesZBL/java_design_patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;组合（Composite）模式用于将对象组合成树形结构以表示 “部分——整体” 的层次结构。它使得用户对单个对象和组合对象的使用具有一致性。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://james.letec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://james.letec.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://james.letec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于 Spring Boot 2.0 构建一个 RESTful WebService</title>
    <link href="https://james.letec.top/2018/04/16/%E5%9F%BA%E4%BA%8E-Spring-Boot-2-0-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA-RESTful-WebService/"/>
    <id>https://james.letec.top/2018/04/16/基于-Spring-Boot-2-0-构建一个-RESTful-WebService/</id>
    <published>2018-04-16T05:12:45.000Z</published>
    <updated>2018-04-17T13:08:05.737Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7134080-edebba8af60420c9.gif?imageMogr2/auto-orient/strip" alt=""></p><p>REST 全称是 Representational State Transfer，中文意思是“表述性状态转移”。RESTful 是关于 Web 的现有特征和使用方式的一些准则和约束。 基于 Spring MVC 的 RestController，我们可以方便的构建一个 RESTful 风格的应用。</p><a id="more"></a><h1 id="使用-Maven-创建项目"><a href="#使用-Maven-创建项目" class="headerlink" title="使用 Maven 创建项目"></a>使用 Maven 创建项目</h1><p>我们可以直接使用 <strong>IntelliJ IDEA</strong> （推荐）中的 <strong>Spring initializer</strong> 快速创建一个基于 <strong>Spring Boot</strong> 的项目，这里使用 <strong>Maven</strong> 构建， <code>pom.xml</code> 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gs-rest-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jayway.jsonpath<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-path<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-release<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-release<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Spring Maven plugin</code> 是 Spring 针对 Maven 开发的一套插件，包含了几个强大的功能：</p><ul><li>无需过多复杂的配置即可<strong>快速构建</strong>一个可执行的 jar 包，使应用的运行可以几乎不受环境的影响</li><li>自动搜索 <code>public static void main()</code> 方法，并将其所在的类标志为<strong>启动类</strong></li><li>对 Spring Boot 的依赖进行自动化管理，所有的依赖项目版本都和 Spring Boot 父项目保持一致（默认情况下），当然也可以手动指定其他版本</li></ul><p>Spring 同样支持 <code>Gradle</code> 构建，详细配置请参考 <a href="https://spring.io/guides/gs/rest-service/" title="Build with Gradle" target="_blank" rel="noopener">Build with Gradle</a></p><h1 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h1><p>这里的实体类并非 <strong>ORM</strong> 中的实体类，而是 REST 中的 “资源” ，我们的 web service 要实现的功能是处理 URL 为 <code>/userinfo/1</code> 的 <code>GET</code> 请求，并将结果以 <strong>JSON</strong> 作为响应体返回，响应状态码为 <code>200 OK</code>，JSON 的格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"张三"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子简单模拟了获取 id 为 1 的用户信息，首先要创建 POJO 类 <code>User</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">long</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>Spring 默认使用 `Jackson` 作为 JSON 解析库将 POJO 类对象序列化为 JSON。</code></pre><h1 id="创建-Controller"><a href="#创建-Controller" class="headerlink" title="创建 Controller"></a>创建 Controller</h1><p>在 controller 类上添加 <code>@RestController</code> 注解即可实现将返回值序列化为 JSON 并充当响应体返回，返回的 <code>content-type</code> 为 <code>application/json</code>，请求 <code>/user/1</code> 将得 id 为 1 的用户的信息，下面是 controller 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String template = <span class="string">"张三"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">userInfo</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span><span class="keyword">long</span> id) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, template);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="让应用跑起来"><a href="#让应用跑起来" class="headerlink" title="让应用跑起来"></a>让应用跑起来</h1><p>传统的构建方式是生成一个 war 文件然后部署到 web 服务器上，这样有时会觉得不太方便，因此推荐使用 Spring Boot 的 Maven 插件快速生成一个独立的可执行的 jar 文件，使用 <code>java -jar</code> 命令即可启动这个应用，所有的类和资源等文件都被集成到这一个 jar 文件中，里面也包括了<strong>嵌入式</strong>的 servlet 容器（比如 Tomcat），下面是这个应用的启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@SpringBootApplication</code> 这个注解是一个组合注解，它包括：</p><ul><li><code>@Configuration</code>：声明这个类是上下文中的 bean 的配置类</li><li><code>@EnableAutoConfiguration</code>：使 Spring 将上下文中扫描到的相关 bean 配置类或 properties 类，并将这些 bean 放到应用上下文中</li><li>Spring 当检测到 classpath 下有 spring-webmvc 的依赖后，会自动给应用启动类上添加 <code>@EnableWebMvc</code> 的注解，它表示这个应用是一个 web 应用，应用启动时就会执行和 web 相关的操作，比如实例化 <code>DispatcherServlet</code> 类并进行相关的配置</li><li><code>@ComponentScan</code>：使 Spring 扫描所有自定义<strong>组件类、配置类、业务类以及控制器</strong>，并将其装配</li></ul><p>在启动类中的 <code>main</code> 方法中调用 <code>SpringBootApplication.run()</code> 即可实现应用的启动，和传统 Java web 应用配置复杂的 <strong>web.xml</strong> 文件截然不同，不需要在配置上花费太多时间</p><h2 id="构建可执行的-jar"><a href="#构建可执行的-jar" class="headerlink" title="构建可执行的 jar"></a>构建可执行的 jar</h2><p>我们可以使用一条简单的命令来完成应用打包成 jar：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./mvnw clean package</span><br></pre></td></tr></table></figure><p>执行这条命令来启动应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span> java -jar target/gs-rest-service-0.1.0.jar</span><br></pre></td></tr></table></figure><h2 id="做一些简单的测试"><a href="#做一些简单的测试" class="headerlink" title="做一些简单的测试"></a>做一些简单的测试</h2><p>在浏览器中访问 <code>htpp://localhost:8080/user/1</code>，没问题的话会得到如下响应：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"张三"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这仅仅是一个 RESTful web service，更多文档请浏览：<a href="https://spring.io/guides/gs/rest-service/" title="Building a RESTful Web Service" target="_blank" rel="noopener">Building a RESTful Web Service</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7134080-edebba8af60420c9.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;REST 全称是 Representational State Transfer，中文意思是“表述性状态转移”。RESTful 是关于 Web 的现有特征和使用方式的一些准则和约束。 基于 Spring MVC 的 RestController，我们可以方便的构建一个 RESTful 风格的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="https://james.letec.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Spring MVC" scheme="https://james.letec.top/tags/Spring-MVC/"/>
    
      <category term="Spring" scheme="https://james.letec.top/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="https://james.letec.top/tags/Spring-Boot/"/>
    
      <category term="RESTful" scheme="https://james.letec.top/tags/RESTful/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 从 http 跳转 https</title>
    <link href="https://james.letec.top/2018/04/15/Nginx%20%E4%BB%8E%20http%20%E8%B7%B3%E8%BD%AC%20https/"/>
    <id>https://james.letec.top/2018/04/15/Nginx 从 http 跳转 https/</id>
    <published>2018-04-15T12:30:53.000Z</published>
    <updated>2018-04-24T12:34:40.387Z</updated>
    
    <content type="html"><![CDATA[<p>网站由 http 升级到 https， 原来的链接是不是就都失效了呢？其实旧链接依然可用，在 Nginx 中简单设置一下即可实现将 http 请求重定向到 https 地址。<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line">    rewrite ^(.*) https://$server_name$1 permanent;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name example.com;</span><br><span class="line">    ssl on;</span><br><span class="line">    # 视具体情况而定</span><br><span class="line">    ssl_certificate     /server/nginx/ssl/example.com.pem;</span><br><span class="line">    ssl_certificate_key /server/nginx/ssl/example.com.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    # location /&#123;</span><br><span class="line">        # ...</span><br><span class="line">    # &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网站由 http 升级到 https， 原来的链接是不是就都失效了呢？其实旧链接依然可用，在 Nginx 中简单设置一下即可实现将 http 请求重定向到 https 地址。&lt;br&gt;
    
    </summary>
    
      <category term="运维" scheme="https://james.letec.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Nginx" scheme="https://james.letec.top/tags/Nginx/"/>
    
      <category term="Linux" scheme="https://james.letec.top/tags/Linux/"/>
    
      <category term="https" scheme="https://james.letec.top/tags/https/"/>
    
      <category term="域名" scheme="https://james.letec.top/tags/%E5%9F%9F%E5%90%8D/"/>
    
      <category term="运维" scheme="https://james.letec.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 解决浏览器 Ajax 跨域问题</title>
    <link href="https://james.letec.top/2018/04/14/Nginx-%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8-Ajax-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>https://james.letec.top/2018/04/14/Nginx-解决浏览器-Ajax-跨域问题/</id>
    <published>2018-04-14T14:52:21.000Z</published>
    <updated>2018-04-14T15:52:32.861Z</updated>
    
    <content type="html"><![CDATA[<p>跨域是指 host 为 A 页面中的 Ajax 发起指向 host B 的请求，只要 A 和 B 的协议、域名、端口、子域名其中任何一项不同，则执行的访问都会被认为是跨域的请求，几乎所有的浏览器为了安全等问题，对跨域访问做了限制，也就是无法通过浏览器发起跨域请求。跨域问题的本质是浏览器的限制。但也并不意味着浏览器根本不能发出任何跨域请求，在发起跨域请求后，浏览器总会发送一个 OPTION 请求，并根据响应的 Header 中 <code>Access-Control-Allow-Origin</code> 参数值进行下一步操作，如果这个参数不存在或不符合当前的域，则拒绝这个跨域请求。解决这个问题的一个简单方法就是使用 Nginx 反向代理。<br><a id="more"></a></p><h1 id="场景示例"><a href="#场景示例" class="headerlink" title="场景示例"></a>场景示例</h1><p>现在假设在同一台主机上部署有两个网站，访问地址分别为 <code>localhost:8080</code>（A） 和 <code>localhost:8081</code>（B）， A 站的某个页面 Ajax 想要访问 B 的某个接口，以 jQuery 的 Ajax 为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.get(</span><br><span class="line">    <span class="string">"http://localhost:8081/api/orders"</span>,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>显然，在没有做任何其他配置的情况下，这个请求一定会发送失败。</p><h1 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h1><p>修改 Nginx 安装目录下 conf/nginx.conf 文件，添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location /&#123;</span><br><span class="line">        proxy_pass http://localhost:8080</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 所有跨域访问以 /api 开头</span><br><span class="line">    location /api &#123;</span><br><span class="line">        # 请求改写</span><br><span class="line">rewrite  ^/api/(.*)$ /$1 break;</span><br><span class="line">proxy_pass   http://localhost:8081;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样配置并启动 Nginx 之后，可以通过 <code>localhost</code> 的 <code>80</code> 端口 访问 <code>8080</code>和 <code>8081</code> 端口的网站</li><li>所有以 <code>/api</code> 开头的请求将被重写，然后被发送给 <code>8081</code> 端口</li><li>对请求的重写为正则式的形式： <code>^/api/(.*)$ /$1 break;</code> <code>$1</code> 表示匹配正则表达式中的第一个分组，也就是 <code>(.*)</code> 匹配的内容，将其改写为 <code>/匹配内容</code>，比如 <code>/api/abc/def/ghi</code> 将被改写为 <code>/abc/def/ghi</code>， <code>break</code> 表示一次匹配成功则结束。</li></ul><h1 id="URL-更改"><a href="#URL-更改" class="headerlink" title="URL 更改"></a>URL 更改</h1><p>原来 Ajax 请求中所有指向 <code>localhost:8081/***</code> 的请求现在都应该改成 <code>localhost/api/***</code>，比如这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.get(</span><br><span class="line">    <span class="string">"http://localhost/api/orders"</span>,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h1><p>CORS （跨域资源共享），需要设置服务端响应头中 <code>Access-Control-Allow-Origin</code> 参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跨域是指 host 为 A 页面中的 Ajax 发起指向 host B 的请求，只要 A 和 B 的协议、域名、端口、子域名其中任何一项不同，则执行的访问都会被认为是跨域的请求，几乎所有的浏览器为了安全等问题，对跨域访问做了限制，也就是无法通过浏览器发起跨域请求。跨域问题的本质是浏览器的限制。但也并不意味着浏览器根本不能发出任何跨域请求，在发起跨域请求后，浏览器总会发送一个 OPTION 请求，并根据响应的 Header 中 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 参数值进行下一步操作，如果这个参数不存在或不符合当前的域，则拒绝这个跨域请求。解决这个问题的一个简单方法就是使用 Nginx 反向代理。&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="https://james.letec.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="服务器" scheme="https://james.letec.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="架构" scheme="https://james.letec.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="Nginx" scheme="https://james.letec.top/tags/Nginx/"/>
    
      <category term="Ajax" scheme="https://james.letec.top/tags/Ajax/"/>
    
      <category term="跨域" scheme="https://james.letec.top/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="CORS" scheme="https://james.letec.top/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu Linux 中虚拟主机的配置 - 搭配 Nginx</title>
    <link href="https://james.letec.top/2018/04/14/Ubuntu-Linux-%E4%B8%AD%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://james.letec.top/2018/04/14/Ubuntu-Linux-中虚拟主机的配置/</id>
    <published>2018-04-14T12:30:53.000Z</published>
    <updated>2018-04-14T14:58:11.127Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟主机，正如其名，就是将一台服务器划分为多个虚拟的主机，可以将每个域名分配给不同的虚拟主机，这样可以充分利用了域名资源和硬件资源。这次我们采用 Nginx 实现虚拟主机的配置。</p><p>Nginx 是一款 free、开源的高性能 HTTP 服务器和反向代理服务器，同时可用作 IMAP、POP3、SMTP 服务器，它经常被用作 HTTP 服务器进行 Web 应用的部署使用，另外，Nginx 还经常以反向代理服务器的身份实现负载均衡。<br><a id="more"></a></p><p>使用 Nginx 配置虚拟主机只需编辑 Nginx 安装目录下 conf/nginx.conf 即可，增加一个虚拟主机只需要在配置文件中添加一个 server 节点，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name test1.example.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html;</span><br><span class="line">        root /home/www/test1/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name test2.example.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html;</span><br><span class="line">        root /home/www/test2/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>listen</code> 为监听的端口，本例中监听 80 端口<br><code>server_name</code> 即指定的虚拟主机名<br><code>location</code> 只 Nginx 代理的相对 URL 范围<br><code>index</code> 指主页的文件名<br><code>root</code> 为网站根目录在系统中的实际位置</p><p><code>location /</code> 表示匹配这个主机名下的所有请求，<code>server_name</code> 的值可以为 <code>*.example.com</code> 这种形式，即匹配所有以 <code>example.com</code> 结尾的主机名，亦或 <code>test.*</code>，即所有以 <code>test</code> 开头的主机名，还可以用正则表达式的形式，比如 <code>~^test\d+\.example\.com$</code>，如果使用正则表达式，最前面要加上 <code>~</code> 这个符号。</p><p>以上两个虚拟主机实现了将对不同主机名的请求指向不同的物理目录，下面介绍如何用虚拟主机实现区分端口，即将不同主机名的请求分发到不同端口上</p><p>和上面的配置写法类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name demo1.example.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name demo2.example.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:8081;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>proxy_pass 表示将请求转发到某个 URL，这样便可以实现虚拟主机名和端口的映射了。如果采用一台物理机部署多个 Tocmat 服务实例则可以采用这种方式，这样就避免了暴露多个端口的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚拟主机，正如其名，就是将一台服务器划分为多个虚拟的主机，可以将每个域名分配给不同的虚拟主机，这样可以充分利用了域名资源和硬件资源。这次我们采用 Nginx 实现虚拟主机的配置。&lt;/p&gt;
&lt;p&gt;Nginx 是一款 free、开源的高性能 HTTP 服务器和反向代理服务器，同时可用作 IMAP、POP3、SMTP 服务器，它经常被用作 HTTP 服务器进行 Web 应用的部署使用，另外，Nginx 还经常以反向代理服务器的身份实现负载均衡。&lt;br&gt;
    
    </summary>
    
      <category term="运维" scheme="https://james.letec.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="架构" scheme="https://james.letec.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="Nginx" scheme="https://james.letec.top/tags/Nginx/"/>
    
      <category term="Linux" scheme="https://james.letec.top/tags/Linux/"/>
    
      <category term="域名" scheme="https://james.letec.top/tags/%E5%9F%9F%E5%90%8D/"/>
    
      <category term="运维" scheme="https://james.letec.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="虚拟主机" scheme="https://james.letec.top/tags/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/"/>
    
  </entry>
  
</feed>
